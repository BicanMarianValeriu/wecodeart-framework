<?php
/**
 * WeCodeArt Framework.
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package 	WeCodeArt Framework
 * @subpackage 	WP-Customizer\Requests;
 * @copyright   Copyright (c) 2021, WeCodeArt Framework
 * @since 		5.0.0
 * @version		5.0.0
 */

namespace WeCodeArt\Admin\Customizer;

defined( 'ABSPATH' ) || exit();

use WeCodeArt\Singleton;
use function WeCodeArt\Functions\get_prop;
use function WeCodeArt\Functions\set_settings_array;

/**
 * Customizer Ajax
 */
class Requests {

	use Singleton;

	/**
	 * Send to Constructor
	 */
	public function init() {
		new Requests\Palette();

		add_action( 'customize_save_after',	[ __CLASS__, 'update_palette' ] );
	}

	/**
     * Update Global Styles based on palette
	 *
	 * @param	object	$wp_customize
	 * @param	object	$choices 		(updated palette)
     * 
     * @return  mixed
     */
	public static function update_palette( \WP_Customize_Manager $wp_customize = null, $choices = null, $value = null ) {
		$setting 	= 'general-design-palette';

		// Get Value:
		// 1 - Customizer: post_value()
		// 2 - Others: from args or fallback to what is currently set.
		// 3 - If slug value is not provided it will only update the colors.
		$value 		= $value ? $value : get_theme_mod( $setting );
		$value 		= $wp_customize ? $wp_customize->get_setting( $setting )->post_value() : $value;
		// Get Choices: via argument or from theme JSON fallback
		$choices 	= $choices ? $choices : wecodeart_json( [ 'settings', 'custom', 'colorPalettes' ], false );

		// Bail early
		if( $choices === false ) return;

		// Making sure is array
		$choices = json_decode( json_encode( $choices ), true );

		$slugs   = wp_list_pluck( $choices, 'slug' );
		
		if ( in_array( $value, $slugs ) ) {
			$user_custom_id     = \WP_Theme_JSON_Resolver_Gutenberg::get_user_custom_post_type_id();
			$user_theme_post	= get_post( $user_custom_id );
			$user_theme_json	= json_decode( $user_theme_post->post_content );
			
			$palette_theme 	= wecodeart_json( [ 'settings', 'color', 'palette', 'theme' ], [] );
			$palette_user 	= wecodeart_json( [ 'settings', 'color', 'palette', 'user' ], $palette_theme );
			
			// Update Palettes
			$user_theme_json = set_settings_array(
				$user_theme_json,
				[ 'settings', 'custom', 'colorPalettes' ],
				$choices
			);

			// Update Styles
			$active = current( wp_list_filter( $choices, [ 'slug' => $value ] ) );
			
			if( ! $active || get_prop( $active, [ 'colors' ], false ) === false ) return;
			
			// Named colors?
			$background = current( wp_list_filter( $palette_user, [ 'color' => $active['colors']['background'] ] ) );
			$selection	= current( wp_list_filter( $palette_user, [ 'color' => $active['colors']['selection'] ] ) );
			$text       = current( wp_list_filter( $palette_user, [ 'color' => $active['colors']['text'] ] ) );
			$link       = current( wp_list_filter( $palette_user, [ 'color' => $active['colors']['link'] ] ) );
			
			$colors = [];
			$colors['background']   = $background ? 'var:preset|color|' . $background['slug'] : $active['colors']['background']; 
			$colors['selection']	= $selection ? 'var:preset|color|' . $selection['slug'] : $active['colors']['selection']; 
			$colors['text']         = $text ? 'var:preset|color|' . $text['slug'] : $active['colors']['text']; 
			
			// Update bg/text colors.
			$user_theme_json = set_settings_array(
				$user_theme_json,
				[ 'styles', 'color' ],
				$colors
			);
			
			// Update links color.
			$user_theme_json = set_settings_array(
				$user_theme_json,
				[ 'styles', 'elements', 'link', 'color', 'text' ],
				$link ? 'var:preset|color|' . $link['slug'] : $active['colors']['link']
			);
			
			// Update the theme.json with the new settings array.
			$user_theme_post->post_content = json_encode( $user_theme_json );
			
			$updated = wp_update_post( $user_theme_post );

			return $updated;
		}
	}
}