<?php
/**
 * WeCodeArt Framework.
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package 	WeCodeArt Framework
 * @subpackage 	Admin
 * @copyright   Copyright (c) 2023, WeCodeArt Framework
 * @since 		3.8.1
 * @version		5.7.2
 */

namespace WeCodeArt;

defined( 'ABSPATH' ) || exit;

use WeCodeArt\Singleton;
use WeCodeArt\Config\Traits\Asset;
use WeCodeArt\Admin\Request;
use WeCodeArt\Admin\Activation;
use WeCodeArt\Admin\Notifications;
use function WeCodeArt\Functions\get_prop;

/**
 * Admin Side Functionality
 */
class Admin {

	use Singleton;
	use Asset;

	const NAMESPACE = 'wecodeart/v1';

	/**
	 * Send to Constructor
	 */
	public function init() {
		\add_action( 'rest_api_init', 			[ $this, 'register_routes' ] );
		\add_action( 'rest_api_init', 			[ $this, 'register_settings' ] );
		\add_action( 'admin_init',				[ $this, 'register_settings' ] );
		\add_action( 'admin_menu',				[ $this, 'register_menu_page' ] );
		\add_action( 'after_switch_theme', 		[ $this, 'insert_default_settings' ] );

		Activation::get_instance();
		Notifications::get_instance();
	}

	/**
	 * Takes an array of new settings, merges them with the old settings, and pushes them into the database.
	 *
	 * @since 	5.0.0
	 *
	 * @param 	string|array 	$new		New settings. Can be a string, or an array.
	 * @param 	string       	$setting	Optional. Settings field name. Default is 'wecodeart-settings'.
	 * @return 	bool 						`true` if option was updated, `false` otherwise.
	 */
	public static function update_options( $new = '', $setting = 'wecodeart-settings' ) {

		$old = get_option( $setting );

		$settings = wp_parse_args( $new, $old );

		// Allow settings to be deleted.
		foreach ( $settings as $key => $value ) {
			if ( 'unset' === $value ) {
				unset( $settings[ $key ] );
			}
		}

		return update_option( $setting, $settings );
	}

	/**
	 * Return option from the options table and cache result.
	 *
	 * Applies `wecodeart/get_option/$key` and `wecodeart_options` filters.
	 *
	 * Values pulled from the database are cached on each request, so a second request for the same value won't cause a
	 * second DB interaction.
	 *
	 * @since 	5.0.0
	 * @version 5.4.5
	 *
	 * @param   string  $key       	Option name.
	 * @param   string  $setting   	Optional. Settings field name. Eventually defaults to `wecodeart` if not
	 *                          	passed as an argument.
	 * @param   bool    $use_cache 	Optional. Whether to use the Genesis cache value or not. Default is true.
	 * @return  mixed   			The value of the `$key` in the database, or the return from
	 * `wecodeart/get_option/{$key}` short circuit filter if not `null`.
	 */
	public static function get_option( $key, $default = false, $setting = null, $use_cache = true ) {
		// The default is set here, so it doesn't have to be repeated in the function arguments for option_value() too.
		$setting = $setting ?: 'wecodeart-settings';

		// Allow child theme to short circuit this function.
		$pre = apply_filters( "wecodeart/options/{$key}", null, $setting );
		if ( null !== $pre ) {
			return $pre;
		}

		// If we need to bypass the cache.
		if ( ! $use_cache ) {
			$options = get_option( $setting );

			if ( ! is_array( $options ) || ! array_key_exists( $key, $options ) ) {
				return $default;
			}

			return is_array( $options[ $key ] ) ? $options[ $key ] : wp_kses_decode_entities( $options[ $key ] );
		}

		// Setup caches.
		static $settings_cache = [];
		static $options_cache  = [];

		// Check options cache.
		if ( isset( $options_cache[ $setting ][ $key ] ) ) {
			// Option has been cached.
			return $options_cache[ $setting ][ $key ];
		}

		// Check settings cache.
		if ( isset( $settings_cache[ $setting ] ) ) {
			// Setting has been cached.
			$options = apply_filters( 'wecodeart/options', $settings_cache[ $setting ], $setting );
		} else {
			// Set value and cache setting.
			$settings_cache[ $setting ] = apply_filters( 'wecodeart/options', get_option( $setting ), $setting );
			$options                    = $settings_cache[ $setting ];
		}

		// Check for non-existent option.
		if ( ! is_array( $options ) || ! array_key_exists( $key, (array) $options ) ) {
			// Cache non-existent option.
			$options_cache[ $setting ][ $key ] = $default;
		} else {
			// Option has not previously been cached, so cache now.
			$options_cache[ $setting ][ $key ] = is_array( $options[ $key ] ) ? $options[ $key ] : wp_kses_decode_entities( $options[ $key ] );
		}

		return $options_cache[ $setting ][ $key ];
	}

	/**
	 * Inserts the default WeCodeArt settings values into the options table, if they don't already exist.
	 *
	 * @since 	5.0.0
	 *
	 * @return bool True of setting added, false otherwise.
	 */
	public function insert_default_settings() {
		return add_option( 'wecodeart-settings', [
			'theme_api_key'	=> 'FREEMIUM',
			'theme_version'	=> wecodeart( 'version' ),
		], '', true );
	}

	/**
	 * Register the default WeCodeArt settings.
	 *
	 * @since 	5.0.0
	 * @version	5.4.5
	 *
	 * @return 	bool True of setting added, false otherwise.
	 */
	public function register_settings() {
		return register_setting( 'wecodeart', 'wecodeart-settings' );
	}

	/**
	 * Register Rest Routes
	 *
	 * @since   5.0.0
	 * @version 5.7.2
	 */
	public function register_routes() {
		register_rest_route( self::NAMESPACE, '/settings', [
			'methods'  => \WP_REST_Server::ALLMETHODS,
			'callback' => function( $request ) {
				// Unset Default Params
				$params = array_filter( $request->get_params(), function( $key ) {
					return( ! in_array( $key, [ 'context', '_locale', '_filter' ] ) );
				}, ARRAY_FILTER_USE_KEY );
			
				// Update if params with values
				if( ! empty( $params ) ) {
					self::update_options( array_filter( $params ) );
				}

				// Get values, updated above
				$data = get_option( 'wecodeart-settings' );

				// If params provided, return only their values
				if( $request->get_param( '_filter' ) ) {
					$data = array_intersect_key( $data, $params );
				}

				return rest_ensure_response( $data );
			},
			'permission_callback' => function() {
				return current_user_can( 'manage_options' );
			},
		] );
		
		register_rest_route( self::NAMESPACE, '/notifications', [
			'methods'  => \WP_REST_Server::ALLMETHODS,
			'callback' => function( $request ) {
				// Unset Default Params
				$params = array_filter( $request->get_params(), function( $key ) {
					return( ! in_array( $key, [ 'context', '_locale' ] ) );
				}, ARRAY_FILTER_USE_KEY );
	
				// Get the response.
				$data 	= [];
				$url 	= 'https://raw.githubusercontent.com/BicanMarianValeriu/wecodeart-framework/master/notifications.json';
				if ( false === ( $data = get_transient( 'wecodeart/transient/notifications' ) ) ) {
					$request	= new Request( $url, [] );
					$request->send( $request::METHOD_GET );
		
					$results = $request->get_response_body();
					$results = json_decode( $results, true );
		
					if( json_last_error() === JSON_ERROR_NONE ) {
						// Clear and sanitize data.
						$data['items'] = array_map( function( $item ) {
							$item = wp_array_slice_assoc( $item, [ 'type', 'title', 'content' ] );

							return self::sanitize_notification( $item );
						}, get_prop( $results, [ 'items' ], [] ) );
			
						set_transient( 'wecodeart/transient/notifications', $data, MINUTE_IN_SECONDS );   
					}
				}

				return rest_ensure_response( $data );
			},
			'permission_callback' => function() {
				return current_user_can( 'manage_options' );
			},
		] );
	}

	/**
	 * Register Admin Page
	 *
	 * @since   5.0.0
	 */
	public function register_menu_page() {
		$page_hook_suffix = add_theme_page(
			__( 'Theme Options', 'wecodeart' ),
			__( 'Theme Options', 'wecodeart' ),
			'manage_options',
			'wecodeart',
			[ $this, 'menu_callback' ]
		);

		add_action( "admin_print_scripts-{$page_hook_suffix}", [ $this, 'enqueue_assets' ] );
	}

	/**
	 * Register Admin Page
	 *
	 * @since   5.0.0
	 */
	public function menu_callback() {
		?><div id="wecodeart" class="wecodeart-admin"></div><?php
	}

	/**
	 * Load assets for option page.
	 *
	 * @since   1.2.0
	 * @version	5.1.7
	 */
	public function enqueue_assets() {
		$version = wecodeart( 'version' );

		wp_enqueue_style(
			$this->make_handle(),
			$this->get_asset( 'css', 'admin/admin' ),
			[ 'wp-components' ],
			$version
		);

		wp_enqueue_script(
			$this->make_handle(),
			$this->get_asset( 'js', 'admin/admin' ),
			[ 'wp-blocks', 'wp-i18n', 'wp-element', 'wp-plugins', 'wp-components', 'wp-edit-post', 'wp-api', 'wp-editor', 'wp-hooks', 'lodash' ],
			$version,
			true
		);

		wp_localize_script( $this->make_handle(), 'wecodeart', [
			'theme'			=> [
				'name'		=> wecodeart( 'name' ),
				'version'	=> wecodeart_if( 'is_dev_mode' ) ? esc_html__( 'Developer Mode', 'wecodeart' ) : $version,
			],
			'currentUser'	=> wp_get_current_user()->display_name,
			'adminUrl'		=> untrailingslashit( esc_url_raw( admin_url() ) ),
		] );
	}

	/**
     * Sanitize
	 *
	 * @param	array $json
     *
     * @return 	array
     */
	private static function sanitize_notification( $json = [] ) {
		$sanitized = [];

		foreach( $json as $key => $value ) {
			switch( $key ) :
				// Strings
				case 'type':
				case 'title':
					$sanitized[$key] = sanitize_text_field( $value );
				break;
				// Content
				case 'content':
					$sanitized[$key] = wp_kses_post( $value );
				break;
				// Unfiltered
				default:
					$sanitized[$key] = $value;
				break;
			endswitch;
		}

		return $sanitized;
	}
}