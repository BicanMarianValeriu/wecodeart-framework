<?php
/**
 * WeCodeArt Framework.
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package 	WeCodeArt Framework
 * @subpackage 	Support\Styles
 * @copyright   Copyright (c) 2022, WeCodeArt Framework
 * @since 		5.0.0
 * @version		5.5.8
 */

namespace WeCodeArt\Support;

defined( 'ABSPATH' ) || exit;

use WeCodeArt\Singleton;
use WeCodeArt\Integration;
use WeCodeArt\Admin\Request;
use WeCodeArt\Conditional\Traits\No_Conditionals;
use function WeCodeArt\Functions\get_prop;

/**
 * The Fonts object.
 */
final class Styles implements Integration {

	use Singleton;
	use No_Conditionals;

	/**
	 * Sanitize
	 *
	 * @since  	5.0.0
	 * @var 	object
	 */
	public 	$Sanitize	= null;
	
	/**
	 * Utilities
	 *
	 * @since  	5.0.0
	 * @var 	object
	 */
	public 	$Utilities	= null;

	/**
	 * Send to Constructor
	 */
	public function init() {
		$this->Sanitize 	= Styles\Sanitize::get_instance();
		$this->Utilities 	= Styles\Utilities::get_instance();
	}

	/**
	 * Register hooks
	 */
	public function register_hooks() {
		// Styles init action
		do_action( 'wecodeart/support/styles/init', $this );	
	}

	/**
	 * Generate breakpoint class
	 *
	 * @param  string   $class
	 * @param  string   $value
	 * @param  bool     $break
	 *
	 * @return string
	 */
	public static function generate_class( string $class = '', $value = '', $break = '' ) {
		$return = join( '-', array_filter( [ $class, $break, $value ], function( $i ) {
			return $i !== '';
		} ) );

		return sanitize_html_class( $return );
	}

	/**
	 * Register CSS utility to be parsed by CSS module.
	 *
	 * @param  array  $args
	 *
	 * @return void
	 */
	public static function register_utility( $args = [] ) {
		$defaults = [
			'property' 	=> '',
			'class'		=> '',
			'values'	=> [],
			'responsive'=> false,
		];

		$args 	= wp_parse_args( $args, $defaults );

		$values = (array) get_prop( $args, 'values', [] );
		
		// Bail if no values.
		if( empty( $values ) ) return;
		
		$properties	= (array) get_prop( $args, 'property' );
		$class 		= get_prop( $args, 'class', current( $properties ) );

		// Bail if no class.
		if( ! $class ) return;

		$media		= wecodeart_json( [ 'settings', 'custom', 'breakpoints' ], [] );
		$responsive = get_prop( $args, 'responsive' ) && ! empty( $media );
		$container  = static::get_instance()->Utilities;

		foreach( $values as $key => $value ) {
			$_class	= static::generate_class( $class, $key );
			$value  = (string) $value;

			$output = [];
			foreach( $properties as $property ) {
				$output['.' . $_class][$property] = "$value!important";
			}
		
			$container->register( $_class, [
				'global' => $output
			] );
			
			// Move on if not responsive
			if( ! $responsive ) continue;

			foreach( $media as $break => $query ) {
				$_class_ = static::generate_class( $class, $key, $break );
				
				$output = [];
				foreach( $properties as $property ) {
					$output['.' . $_class_][$property] = "$value!important";
				}

				$container->register( $_class_, [
					"@media (min-width:{$query})" => $output
				] );
			}
		}
	}

    /**
     * Trim CSS
     *
     * @since 	3.7.7
     * @version 5.0.0
	 * 
     * @param 	string $css CSS content to trim.
     *
     * @return 	string
     */
    public static function compress( string $css = '', $options = [] ) {
        // Return if no CSS
        if ( ! $css ) {
            return '';
        }

		$options = wp_parse_args( $options, [
			'comments' => false,
			'zeroUnit' => false,
		] );

		if( get_prop( $options, 'comments' ) ) {
			// remove comments
			$css = preg_replace( '!/\*[^*]*\*+([^/][^*]*\*+)*/!', '', $css );
		}

        // Normalize whitespace
        $css = preg_replace( '/\s+/', ' ', $css );

        // Remove ; before }
        $css = preg_replace( '/;(?=\s*})/', '', $css );

        // Remove space after , : ; { } */ >
        $css = preg_replace( '/(,|:|;|\{|}|\*\/|>) /', '$1', $css );

        // Remove space before , ; { }
        $css = preg_replace( '/ (,|;|\{|})/', '$1', $css );

        // Strips leading 0 on decimal values (converts 0.5px into .5px)
        $css = preg_replace( '/(:| )0\.([0-9]+)(%|em|rem|ex|px|in|cm|mm|pt|pc)/i', '${1}.${2}${3}', $css );

		if( get_prop( $options, 'zeroUnit' ) ) {
			// Strips units if value is 0 (converts 0px to 0)
			$css = preg_replace( '/(:| )(\.?)0(%|em|rem|ex|px|in|cm|mm|pt|pc)/i', '${1}0', $css );
		}

        // Trim
        $css = trim( $css );
        
        // Double call for media queries
        $css = self::clean_empty( $css );
		$css = self::clean_empty( $css );
		
        // Return minified CSS
        return $css;
    }

    /**
     * Get CSS without empty selector
     * Call after minification of CSS
     *
     * @since   5.0.0
     * @param   string $css
     *
     * @return  string
     */
    public static function clean_empty( string $css ) {
        $css_explode        = explode( '}', $css );
        $result             = '';
        $double_braces_open = false;
        foreach ( $css_explode as $index => $item ) {
            $is_double_braces = substr_count( $item, '{' ) > 1;
            if ( $is_double_braces || ( $item != '' && substr( $item, -1 ) != '{' ) ) {
                if ( $is_double_braces ) {
                    $inner_explode = explode( '{', $item );
                    $inner_item    = $inner_explode[0] . '{';
                    if ( isset( $inner_explode[2] ) && $inner_explode[2] != '' ) {
                        $inner_item .= $inner_explode[1] . '{' . $inner_explode[2] . '}';
                    }
                    $result .= $inner_item;
                } else {
                    $result .= $item . '}';
                }

                if ( $is_double_braces ) {
                    $double_braces_open = true;
                }
            }
            if ( $double_braces_open && $item == '' ) {
                $result            .= '}';
                $double_braces_open = false;
            }
        }

        return $result;
    }

    /**
	 * Gets the array of generated styles and creates the minimized, inline CSS.
	 *
	 * @param 	array   $css    The CSS definitions array.
	 *
	 * @return 	string          The generated CSS.
	 */
	public static function parse( array $css = [], $context = '' ) {
		// Pass our styles from filter.
		$css = apply_filters( 'wecodeart/filter/styles/array', $css, $context );

		// Process the array of CSS properties and produce the final CSS.
		$final_css = '';

		if ( ! is_array( $css ) || empty( $css ) ) {
			return $final_css;
		}

		foreach( $css as $query => $selectors ) {
			$final_css .= ( 'global' !== $query ) ? $query . '{' : '';
			$final_css .= self::array_to_string( $selectors );
			$final_css .= ( 'global' !== $query ) ? '}' : '';
		}

		return $final_css;
	}

	/**
	 * Utility method to convert associative array to css rules.
	 *
	 * @param 	array 		$rules The associative rules array.
	 * @param 	int   		$indent The indent to be used per rule.
	 *
	 * @return string
	 */
	public static function array_to_string( array $selectors = [], $indent = 0 ) {
		$css    = '';
		$prefix = str_repeat( '  ', $indent );

		foreach( $selectors as $selector => $properties ) {
			$css_for_style = '';
			foreach( $properties as $property => $value ) {
				if ( is_string( $value ) && '' !== $value ) {
					$css_for_style .= $property . ':' . $value . ';';
				} elseif( is_array( $value ) ) {
					foreach ( $value as $subvalue ) {
						if ( is_string( $subvalue ) && '' !== $subvalue ) {
							$css_for_style .= $property . ':' . $subvalue . ';';
						}
					}
				}
			}
			
			if ( '' !== $css_for_style ) {
				$css .= $selector . '{' . $css_for_style . '}';
			}
		}

		// foreach ( $selectors as $key => $value ) {
		// 	if ( is_array( $value ) ) {
		// 		$selector   = $key;
		// 		$properties = $value;

		// 		$css .= $prefix . "$selector {\n";
		// 		$css .= $prefix . self::array_to_css( $properties, $indent + 1 );
		// 		$css .= $prefix . "}\n";
		// 		continue;
		// 	}

		// 	$property 	= $key;
		// 	$css	.= $prefix . "$property: $value;\n";
		// }

		if ( preg_match( '#</?\w+#', $css ) ) {
			$css = '';
		}

		return $css;
	}
	
	/**
	 * Gets the array of generated styles from a string.
	 *
	 * @param 	string	$css	The CSS definitions string.
	 * @param 	bool   	$group	If true, it will group CSS into media queries.
	 *
	 * @return 	array          	The generated CSS array.
	 */
	public static function string_to_array( string $css = '' ) {
		$results = [];
		// Escape base64 images
		$css = preg_replace( '/(data\:[^;]+);/i', '$1~£&#', $css );
		// Split rules
		preg_match_all( '/(?ims)([a-z0-9\s\,\.\:#_\-@]+)\{([^\}]*)\}/', $css, $arr );

		foreach( $arr[0] as $i => $x ) {
			$selector 	= trim( $arr[1][$i] );
			$results[$selector] = [];
			foreach( explode( ';', $arr[2][$i] ) as $attr ) {
				if ( strlen( trim( $attr ) ) > 0) {
					list( $name, $value ) = explode( ':', trim( $attr ), 2 );
					$results[$selector][trim( $name )] = str_replace( '~£&#', ';', trim( $value ) );
				}
			}
		}

		return $results;
	}

	/**
	 * Gets the array of CSS with media queries.
	 *
	 * @param 	string   $css	The CSS definitions string.
	 *
	 * @return 	array          	The generated CSS array.
	 */
	public static function string_to_array_query( string $css = '' ) {
		$queries 	= [];
		$start 		= 0;
		$global 	= preg_replace( '/@media[^{]+\{([\s\S]+?\})\s*\}/i', '', $css );
		$queries['global'] = self::string_to_array( $global );

		while( ( $start = strpos( $css, '@media', $start ) ) !== false ) {
			$s = [];
			$i = strpos( $css, '{', $start );
			if ( $i !== false ) {
				array_push( $s, $css[$i] );
				$i++;
				while( ! empty( $s ) ) {
					if ( $css[$i] === '{' ) array_push( $s, '{' ); 
					elseif ( $css[$i] === '}' ) array_pop( $s ); 
					$i++;
				}
				preg_match( '/(\@media[^\{]+)\{(.*)\s+/ims', substr( $css, $start, ( $i + 1 ) - $start ), $block );
				list( , $media, $style ) = $block;
				$query 	= trim( $media );
				$styles	= self::string_to_array( $style );
				$queries[$query] = isset( $queries[$query] ) ? $queries[$query] + $styles : $styles;
				$start = $i;
			}
		}
		
		return $queries;
	}

	/**
	 * Add prefixes if necessary.
	 *
	 * @param  array $css The CSS definitions array.
	 *
	 * @return array
	 */
	public static function add_prefixes( array $css ) {
		if( is_array( $css ) ) {
			foreach( $css as $media_query => $elements ) {
				if( empty( $elements ) ) continue;
				foreach( $elements as $element => $properties ) {
					if( empty( $properties ) ) continue;
					foreach( $properties as $property => $value ) {
						// Missing then skip.
						if( ! $property ) continue;
						// Add -webkit-* and -moz-*.
						if ( is_string( $property ) && in_array( $property, [
							'border-radius',
							'box-shadow',
							'box-sizing',
							'text-shadow',
							'transform',
							'background-size',
							'transition',
							'transition-property',
						], true ) ) {
							unset( $css[ $media_query ][ $element ][ $property ] );
							$css[ $media_query ][ $element ][ '-webkit-' . $property ] = $value;
							$css[ $media_query ][ $element ][ '-moz-' . $property ]    = $value;
							$css[ $media_query ][ $element ][ $property ]              = $value;
						}

						// Add -ms-* and -o-*.
						if ( is_string( $property ) && in_array( $property, [
							'transform',
							'background-size',
							'transition',
							'transition-property',
						], true ) ) {
							unset( $css[ $media_query ][ $element ][ $property ] );
							$css[ $media_query ][ $element ][ '-ms-' . $property ] = $value;
							$css[ $media_query ][ $element ][ '-o-' . $property ]  = $value;
							$css[ $media_query ][ $element ][ $property ]          = $value;
						}
					}
				}
			}
		}

		return $css;
    }

	/**
	 * Convert HEX to RGBA.
	 *
	 * @since   5.0.0
	 * @param 	string $color   Color data.
	 * @param 	bool   $opacity Opacity status.
	 *
	 * @return 	mixed
	 */
	public static function hex_to_rgba( string $color, $opacity = false ) {
		$default = 'rgb(0,0,0)';

		if ( empty( $color ) ) {
			return $default;
		}

		if ( '#' == $color[0] ) {
			$color = substr( $color, 1 );
		}

		if ( strlen( $color ) == 6 ) {
			$hex = array( $color[0] . $color[1], $color[2] . $color[3], $color[4] . $color[5] );
		} elseif ( strlen( $color ) == 3 ) {
			$hex = array( $color[0] . $color[0], $color[1] . $color[1], $color[2] . $color[2] );
		} else {
			return $default;
		}

		$rgb = array_map( 'hexdec', $hex );

		if ( $opacity ) {
			if ( abs( $opacity ) > 1 ) {
				$opacity = 1.0;
			}
			$output = 'rgba(' . implode( ',', $rgb ) . ',' . $opacity . ')';
		} else {
			$output = 'rgb(' . implode( ',', $rgb ) . ')';
		}

		return $output;
	}

	/**
	 * Adjust Color Brightness
	 *
	 * @since   5.0.0
	 * @param 	string	$color   Color data.
	 * @param 	integer	$opacity Opacity status.
	 *
	 * @return 	string
	 */
	public static function hex_brightness( string $hex, $steps ) {
		// Steps should be between -255 and 255. Negative = darker, positive = lighter
		$steps = max( -255, min( 255, $steps ) );
	
		// Normalize into a six character long hex string
		$hex = str_replace( '#', '', $hex );
		if ( strlen( $hex ) == 3 ) {
			$hex = str_repeat( substr( $hex, 0 , 1 ), 2 );
			$hex .= str_repeat( substr( $hex, 1, 1 ), 2 );
			$hex .= str_repeat( substr( $hex, 2, 1 ), 2 );
		}
	
		// Split into three parts: R, G and B
		$color_parts = str_split( $hex, 2 );
		$return = '#';
	
		foreach ( $color_parts as $color ) {
			$color   = hexdec( $color ); // Convert to decimal
			$color   = max( 0, min( 255, $color + $steps ) ); // Adjust color
			$return .= str_pad( dechex( $color ), 2, '0', STR_PAD_LEFT ); // Make two char hex code
		}
	
		return $return;
	}
	
	/**
	 * Color lightness
	 *
	 * @since   5.0.0
	 * @param  	string 	$color  Color in HEX/RGB/RGBA format
	 *
	 * @return 	string
	 */
	public static function color_lightness( string $color ) {
		$mode 	= ( false === strpos( $color, 'rgba' ) ) ? 'hex' : 'rgba';
		$color 	= $mode === 'hex' ? self::hex_to_rgba( $color ) : $color; 
		preg_match_all( "/\(([^\]]*)\)/" , $color, $matches );
		
		return intval( array_sum( explode( ',', current( $matches[1] ) ) ) );
	}

	/**
	 * Sort by breakpoints.
	 *
     * @param   array $order
     *
	 * @return  array
	 */
	public static function sort_breakpoints( $order ) {
        $breaks     = wecodeart_json( [ 'settings', 'custom', 'breakpoints' ], [] );
        $sortArray  = [ 'global' ] + array_map( function( $point ) {
            return "@media (min-width:{$point})";
        }, array_values( $breaks ) );
        
		$ordered    = [];
        foreach ( $sortArray as $key ) {
            if ( array_key_exists( $key, $order ) ) {
                $ordered[$key] = $order[$key];
                unset( $order[$key] );
            }
        }

        return $ordered + $order;
	}
}