<?php
/**
 * WeCodeArt Framework.
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package 	WeCodeArt Framework
 * @subpackage 	Support\Styles\Processor
 * @copyright   Copyright (c) 2021, WeCodeArt Framework
 * @since 		4.2.0
 * @version		4.2.0
 */

namespace WeCodeArt\Support\Styles;

defined( 'ABSPATH' ) || exit;

use WeCodeArt\Support\Styles;
use function WeCodeArt\Functions\get_prop;

/**
 * CSS Processor.
 */
abstract class Processor {

	/**
	 * The field's `output` argument.
	 *
	 * @var 	array
	 */
	protected 	$output = [];

	/**
	 * An array of the generated styles.
	 *
	 * @var 	array
	 */
	protected 	$styles = [];

	/**
	 * Constructor
	 *
	 * @access  public
	 * @param   array 	$args Args object.
	 */
	public function __construct( $args ) {
		$this->output 	= get_prop( $args, 'output', [] );

		$this->parse_output();
	}

	/**
	 * If we have a sanitize_callback defined, apply it to the value.
	 *
	 * @param 	array        $output The output args.
	 *
	 * @return 	string|array
	 */
	protected function apply_sanitize_callback( $output ) {
		if ( isset( $output['sanitize_callback'] ) && null !== $output['sanitize_callback'] ) {
			// If the sanitize_callback is invalid, return the value.
			if ( ! is_callable( $output['sanitize_callback'] ) ) {
				return $output['value'];
			}
			
			return call_user_func( $output['sanitize_callback'], $output['value'] );
		}

		return $output['value'];
	}

	/**
	 * If we have a value_pattern defined, apply it to the value.
	 *
	 * @param 	array        $output 	The output args.
	 * @param 	string		 $type  	The value type.
	 *
	 * @return 	string|array
	 */
	protected function apply_value_pattern( $output, $type = '' ) {
		$value = $output['value'];
		if ( isset( $output['pattern'] ) && ! empty( $output['pattern'] ) && is_string( $output['pattern'] ) ) {
			if ( ! is_array( $value ) ) {
				$value = str_replace( '$', $value, $output['pattern'] );
			}
			if ( is_array( $value ) ) {
				foreach ( array_keys( $value ) as $value_k ) {
					if ( is_array( $value[ $value_k ] ) ) {
						continue;
					}
					if ( isset( $output['choice'] ) ) {
						if ( $output['choice'] === $value_k ) {
							$value[ $output['choice'] ] = str_replace( '$', $value[ $output['choice'] ], $output['pattern'] );
						}
						continue;
					}
					$value[ $value_k ] = str_replace( '$', $value[ $value_k ], $output['pattern'] );
				}
			}
			$value = $this->apply_pattern_replace( $output, $type );
		}
		
		return $value;
	}

	/**
	 * If we have a value_pattern defined, apply it to the value.
	 *
	 * @param 	array        $output 	The output args.
	 * @param 	string		 $type  	The value type.
	 *
	 * @return 	string|array
	 */
	protected function apply_pattern_replace( $output, $type ) {
		$value = $output['value'];

		if ( isset( $output['pattern_replace'] ) && is_array( $output['pattern_replace'] ) ) {
			$option_type = $type ?: 'theme_mod';
			$option_name = 'wecodeart-settings';
			$options     = [];

			if ( $option_name ) {
				$options = ( 'site_option' === $option_type ) ? get_site_option( $option_name ) : get_option( $option_name );
			}
			
			foreach ( $output['pattern_replace'] as $search => $replace ) {
				$replacement = '';
				switch ( $option_type ) {
					case 'option':
						if ( is_array( $options ) ) {
							if ( $option_name ) {
								$subkey      = str_replace( [ $option_name, '[', ']' ], '', $replace );
								$replacement = ( isset( $options[ $subkey ] ) ) ? $options[ $subkey ] : '';
								break;
							}
							$replacement = ( isset( $options[ $replace ] ) ) ? $options[ $replace ] : '';
							break;
						}
						$replacement = get_option( $replace );
						break;
					case 'site_option':
						$replacement = ( is_array( $options ) && isset( $options[ $replace ] ) ) ? $options[ $replace ] : get_site_option( $replace );
						break;
					case 'user_meta':
						$user_id = get_current_user_id();
						if ( $user_id ) {
							$replacement = get_user_meta( $user_id, $replace, true );
						}
						break;
					default:
						$replacement = get_theme_mod( $replace );
						if ( ! $replacement ) {
							$replacement = $replace;
						}
				}

				$replacement = ( false === $replacement ) ? '' : $replacement;

				if ( is_array( $value ) ) {
					foreach ( $value as $k => $v ) {
						$_val        = ( isset( $value[ $v ] ) ) ? $value[ $v ] : $v;
						$value[ $k ] = str_replace( $search, $replacement, $_val );
					}

					return $value;
				}

				$value = str_replace( $search, $replacement, $value );
			}
		}

		return $value;
	}

	/**
	 * Parses the output arguments.
	 * Calls the process_output method for each of them.
	 */
	protected function parse_output() {
		foreach ( $this->output as $output ) {
			$skip = false;

			// Apply any sanitization callbacks defined.
			$value = $this->apply_sanitize_callback( $output );

			// Skip if value is empty.
			if ( '' === $output['value'] ) {
				$skip = true;
			}

			// No need to proceed this if the current value is the same as in the "exclude" value.
			if ( isset( $output['exclude'] ) && is_array( $output['exclude'] ) ) {
				foreach ( $output['exclude'] as $exclude ) {
					if ( is_array( $value ) ) {
						if ( is_array( $exclude ) ) {
							$diff1 = array_diff( $value, $exclude );
							$diff2 = array_diff( $exclude, $value );

							if ( empty( $diff1 ) && empty( $diff2 ) ) {
								$skip = true;
							}
						}
						if ( isset( $output['choice'] ) && isset( $value[ $output['choice'] ] ) && $exclude == $value[ $output['choice'] ] ) { // phpcs:ignore WordPress.PHP.StrictComparisons.LooseComparison
							$skip = true;
						}
					}
					if ( $skip ) {
						continue;
					}

					// Skip if value is defined as excluded.
					if ( $exclude === $value || ( '' === $exclude && empty( $value ) ) ) {
						$skip = true;
					}
				}
			}
			if ( $skip ) {
				continue;
			}

			// Apply any value patterns defined.
			$value = $this->apply_value_pattern( $output );

			if ( isset( $output['element'] ) && is_array( $output['element'] ) ) {
				$output['element'] = array_unique( $output['element'] );
				sort( $output['element'] );
				$output['element'] = implode( ',', $output['element'] );
			}

			$value = $this->process_value( $value, $output );

			if ( ( is_admin() && ! is_customize_preview() ) || ( isset( $_GET['editor'] ) && '1' === $_GET['editor'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification
				// Check if this is an admin style.
				if ( ! isset( $output['context'] ) || ! in_array( 'editor', $output['context'], true ) ) {
					continue;
				}
			} elseif ( isset( $output['context'] ) && ! in_array( 'front', $output['context'], true ) ) {
				// Check if this is a frontend style.
				continue;
			}

			$this->process_output( $output, $value );
		}
	}

	/**
	 * Parses an output and creates the styles array for it.
	 *
	 * @param 	array        $output The field output.
	 * @param 	string|array $value  The value.
	 *
	 * @return 	null
	 */
	protected function process_output( $output, $value ) {
		if ( ! isset( $output['element'] ) || ! isset( $output['property'] ) ) {
			return;
		}

		$output = wp_parse_args( $output, [
			'media_query' 	=> 'global',
			'units'			=> '',
			'prefix'      	=> '',
			'suffix'      	=> '',
		] );

		// Properties that can accept multiple values.
		// Useful for example for gradients where all browsers use the "background-image" property
		// and the browser prefixes go in the value_pattern arg.
		// $accepts_multiple = array(
		// 	'background-image',
		// 	'background',
		// );

		// if ( in_array( $output['property'], $accepts_multiple, true ) ) {
		// 	if (
		// 		isset( $this->styles[ $output['media_query'] ][ $output['element'] ][ $output['property'] ] ) && 
		// 		! is_array( $this->styles[ $output['media_query'] ][ $output['element'] ][ $output['property'] ] ) 
		// 	) {
		// 		$value = (array) $this->styles[ $output['media_query'] ][ $output['element'] ][ $output['property'] ];
		// 		$this->styles[ $output['media_query'] ][ $output['element'] ][ $output['property'] ] = $value;
		// 	}
		// 	$this->styles[ $output['media_query'] ][ $output['element'] ][ $output['property'] ][] = $output['prefix'] . $value . $output['units'] . $output['suffix'];
		// 	return;
		// }

		if ( is_string( $value ) || is_numeric( $value ) ) {
			$value = $output['prefix'] . $value . $output['units'] . $output['suffix'];
			$this->styles[ $output['media_query'] ][ $output['element'] ][ $output['property'] ] = $value;
		}
	}

	/**
	 * Returns the property vvalue.
	 *
	 * @param 	string  		$property 	The CSS Property.
	 * @param 	mixed       	$value 		The Property Value.
	 *
	 * @return 	string|array
	 */
	protected function get_property_value( $property, $value ) {
		return Styles::get_property_value( $property, $value );
	}

	/**
	 * Returns the value.
	 *
	 * @param 	string|array $value The value.
	 * @param 	array        $output The field "output".
	 *
	 * @return 	string|array
	 */
	protected function process_value( $value, $output ) {
		if ( isset( $output['property'] ) ) {
			return $this->get_property_value( $output['property'], $value );
		}
		
		return $value;
	}

	/**
	 * Exploses the private $styles property to the world
	 *
	 * @return array
	 */
	public function get_styles() {
		return $this->styles;
	}
}