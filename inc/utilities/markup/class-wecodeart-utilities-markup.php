<?php
/**
 * WeCodeArt Framework.
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package 	WeCodeArt Framework
 * @subpackage  Markup Functions
 * @copyright   Copyright (c) 2019, WeCodeArt Framework
 * @since		3.5
 * @version		3.7.2
 */

namespace WeCodeArt\Utilities;

if ( ! defined( 'ABSPATH' ) ) exit();

/**
 * Markup Utilities Parent Class
 */
class Markup {

	use \WeCodeArt\Singleton; 

	/**
	 * Merge array of attributes with defaults, and apply contextual filter on array.
	 * @since 	3.5
	 *
	 * @param 	string 	$context    The context, to build filter name.
	 * @param 	array  	$attributes Optional. Extra attributes to merge with defaults.
	 * @param 	array  	$args       Optional. Custom data to pass to filter.
	 *
	 * @return 	array 	Merged and filtered attributes.
	 */
	public static function parse_attr( $context, $attributes = array(), $args = array() ) {
		$defaults = array(
			'class' => sanitize_html_class( $context ),
		);
		$attributes = wp_parse_args( $attributes, $defaults );

		// Contextual filter.
		return apply_filters( "wecodeart/filter/attributes/{$context}", $attributes, $context, $args );
	}

	/**
	 * Build list of attributes into a string and apply contextual filter on string.
	 *
	 * @since 	3.5
	 *
	 * @param 	string 	$context    The context, to build filter name.
	 * @param 	array  	$attributes Optional. Extra attributes to merge with defaults.
	 * @param 	array  	$args       Optional. Custom data to pass to filter.
	 *
	 * @return 	string 	String of HTML attributes and values.
	 */
	public static function generate_attr( $context, $attributes = array(), $args = array() ) {
		$attributes = self::parse_attr( $context, $attributes, $args );
		$output = '';

		// Cycle through attributes, build tag attribute string.
		foreach( $attributes as $key => $value ) {
			if ( ! $value ) continue;
			if ( true === $value ) $output .= esc_html( $key ) . ' ';
			else $output .= sprintf( '%s="%s" ', esc_html( $key ), esc_attr( $value ) );
		}

		$output = apply_filters( "wecodeart/filter/attributes/{$context}/output", $output, $attributes, $context, $args );
		return trim( $output );
	}

	/**
	 * Return Sortable callback functions based on input.
	 *
	 * @param	array  	modules	required
	 * @param 	array 	options	required
	 * @param 	boolean	echo	optional
	 *
	 * @return 	string/object 	HTML/WP_Error
	 */
	public static function sortable( array $modules, array $options, $echo = true ) { 
		$_callbacks = array_map( function( $module ) {
			return array_key_exists( 'callback', $module ); 
		}, $modules );

		// Only run if we have callbacks set for all of the modules
		if( count( array_unique( $_callbacks ) ) !== 1  ) {
			return new \WP_Error( 'wecodeart_markup_has_no_callbacks', 
				__( 'Some of the modules array item does not have a callback function defined.', 'wecodeart' ) 
			);
		}

		// Variable Holder
		$functions = array();
		
		// If key from options exists in modules array, loads it's callback functions.
		foreach( $options as $opt ) if( array_key_exists( $opt, $modules ) ) $functions[] = $modules[$opt]['callback'];

		// Bail if there are no functions to return.
		if( ! $functions ) return;
		
		// Build the HTML
		$output = '';
		ob_start();
		foreach( $functions as $f ) {
			if( is_array( $f ) && method_exists( $f[0], $f[1] ) || is_string( $f ) && function_exists( $f ) ) 
				call_user_func( $f );
		}
		$output .= ob_get_clean();	
		// Return the output
		if( $echo ) echo $output; 
		else return $output;
	}

	/**
     * Wrapper method for any html
	 *
	 * @since 	unknown
	 * @version	3.7.2
	 *
	 * @param	string	context		required ( used by generate_attr's dynamic filter )
	 * @param 	mixed	function	required ( the function called to be wrapped )
	 * @param 	array	args		required ( wrappers array - must have tag/attrs key defined )
	 * @param 	array	func_args	optional ( optional params for the function called above )
	 *
	 * @return 	string/object 	HTML/WP_Error
	 */
	public static function wrap( string $context, array $wrappers, $content = '', $func_args = [], $echo = true ) {
		// Wrapper must have a 'tag' defined
		$_wrappers = array_map( function( $wrapper ) {
			return array_key_exists( 'tag', $wrapper ); 
		}, $wrappers );

		// Make sure $args are an array.
		if ( empty( $wrappers ) || ( ! empty( $wrappers ) && count( array_unique( $_wrappers ) ) !== 1 ) ) {
			return new \WP_Error( 'wecodeart_markup_no_wrappers', 
				__( 'Wrappers are missing or are not properly defined. Each wrapper must contain a "tag" key', 'wecodeart' )
			);
		}

		// Set defaults.
		$defaults = [];

		// Parse args.
		$args = wp_parse_args( $wrappers, $defaults );

		// Build the HTML
		$function_html = '';

		if( is_callable( $content ) ) {
			ob_start();
			call_user_func_array( $content, $func_args );
			$function_html .= ob_get_clean();
		} else {
			$function_html .= $content;
		}

		if( empty( $function_html ) ) return;

		$html = '';
		
		foreach( $args as $key => $elem ) {
			$_context = $context . '/' . $key; // Dynamic context filter for each wrapper.
			$open_tag = trim( implode( ' ', [ esc_html( $elem['tag'] ), self::generate_attr( $_context, $elem['attrs'] ) ] ) );
			$html .= '<' . $open_tag . '>';
		}

		$html .= $function_html;
		
		/**
		 * Close the wrappers in reverse order
		 * @since 3.7.2
		 */
		$args = array_reverse( $args );

		foreach( $args as $key => $elem ) {
			$html .= '</' . esc_html( $elem['tag'] ) . '>';
		}

		/**
		 * Developer Comments
		 * @since 3.7.0
		 */
		if( WP_DEBUG === true ) {
			$comment = implode( '.', explode( ' ', $args[0]['attrs']['class'] ) );
			$comment .= " @filter = `wecodeart/filter/attributes/{$context}`";
			$html .= "<!-- /.{$comment} -->";
		}

		/**
		 * Filter the final HTML output of the function
		 * @since 	3.6.0
		 * @return 	string of HTML
		 */
		$output = apply_filters( "wecodeart/filter/wrap/{$context}/output", $html, $context );

		// Return the output
		if( $echo ) echo $output; 
		else return $output;
	}
}