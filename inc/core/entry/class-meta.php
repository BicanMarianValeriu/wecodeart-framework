<?php
/**
 * WeCodeArt Framework.
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package 	WeCodeArt Framework
 * @subpackage 	Core\Entry\Meta
 * @copyright   Copyright (c) 2020, WeCodeArt Framework
 * @since 		3.6
 * @version		4.0.1
 */

namespace WeCodeArt\Core\Entry;

defined( 'ABSPATH' ) || exit();

use WeCodeArt\Markup;
use WeCodeArt\Markup\SVG;

/**
 * Handles Entry Meta output
 */
class Meta {

	use \WeCodeArt\Singleton;

	/**
	 * Send to Constructor
	 * @since 3.6.4
	 */
	public function init() {
		add_post_type_support( 'post', 'wecodeart-post-info' );
		add_action( 'wecodeart/hook/entry/header', [ $this, 'render' ], 30 ); 
	}
	
	/**
	 * Entry Meta Author Template
	 *
	 * @since	1.0
	 * @version	4.2
	 *
	 * @param 	int		$author_id
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function author( $author_id = 0, $echo = true ) {
		// Only if post type supports.
		if ( ! post_type_supports( get_post_type(), 'author' ) ) {
			return;
		}

		$author_id 	= $author_id ?: get_the_author_meta( 'ID' );
		$author		= get_the_author_meta( 'display_name', $author_id );
		$author_url = get_author_posts_url( $author_id );

		// In order to render something when ajax refreshed in customizer.
		$author_name = $author ?: esc_html__( 'Author Name', 'wecodeart' );
		
		Markup::template( 'entry/meta/author', [
			'author' => (object) [
				'id' 	=> $author_id,
				'url' 	=> $author_url,
				'name' 	=> $author_name,
			],
			'author_url' 	=> $author_url,
			'author_name' 	=> $author_name
		], $echo );
	}

	/**
	 * Entry Meta Date Template
	 *
	 * @since	1.0
	 * @version	3.9.5
	 *
	 * @param 	array	$args
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function date( $args = [], $echo = true ) {
		$defaults = [
			'published'		=> [
				'robot'	=> get_the_date( DATE_W3C ),
				'human' => get_the_date()
			],
		];

		if ( get_the_time( 'U' ) !== get_the_modified_time( 'U' ) ) {
			$defaults = wp_parse_args( [
				'modified' => [
					'robot'	=> get_the_modified_date( DATE_W3C ),
					'human' => get_the_modified_date()
				],
			], $defaults );
		}

		$args = wp_parse_args( $args, $defaults );

		Markup::template( 'entry/meta/date', $args, $echo );
	} 

	/**
	 * Entry Meta Categories Template
	 *
	 * @since	1.0
	 * @version	4.1.5
	 * 
	 * @param 	array	$args
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function categories( $args = [], $echo = true ) {
		// Do nothing if no tags
		if ( empty( $count = get_the_terms( null, 'category' ) ) ) {
			return;
		}

		Markup::template( 'entry/meta/categories', wp_parse_args( $args, [
			'post_id' 	=> (int) get_the_ID(),
			'count'		=> (int) $count,
			'separator' => ', ',
		] ), $echo );
	}

	/**
	 * Entry Meta Tags Template
	 *
	 * @since	1.0
	 * @version	3.9.5
	 *
	 * @param 	array	$args
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function tags( $args = [], $echo = true ) {
		// Do nothing if no tags
		if ( empty( get_the_tags() ) ) {
			return;
		}

		Markup::template( 'entry/meta/tags', wp_parse_args( $args, [
			'post_id' 	=> get_the_ID(),
			'separator' => ', ',
		] ), $echo );
	} 

	/**
	 * Entry Meta Comments Template
	 *
	 * @since	1.0
	 * @version	3.9.6
	 * 
	 * @param 	array	$args
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function comments( $args = [], $echo = true ) {
		// Only if post type supports.
		if ( ! post_type_supports( get_post_type(), 'comments' ) ) {
			return;
		}

		// Show only where comments are enabled or have comments (even if disabled)
		if ( ! comments_open() && true === (bool) apply_filters( 'wecodeart/filter/entry/meta/comments/hide_if_off', true ) ) { 
			return;
		}

		Markup::template( 'entry/meta/comments', wp_parse_args( $args, [
			'number'	=> (int) get_comments_number( get_the_ID() ),
			'i18n' 		=> [
				'more'		=> esc_html__( '% Comments', 			'wecodeart' ),
				'one'		=> esc_html__( '1 Comment', 			'wecodeart' ),
				'zero'		=> esc_html__( 'Leave a Comment', 		'wecodeart' ),
				'closed'	=> esc_html__( 'Comments are Closed', 	'wecodeart' )
			]
		] ), $echo );
	}

	/**
	 * Entry Meta Edit Template
	 *
	 * @since	1.0
	 * @version	3.9.6
	 *
	 * @param 	array	$args
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function edit_link( $args = [], $echo = true ) {
		if( ! is_user_logged_in() ) {
			return;
		}
		
		Markup::template( [ 'entry/meta/edit', 'link' ], wp_parse_args( $args, [
			'post_id' => get_the_ID(),
		] ), $echo );
	}

	/**
	 * Get Contextual options
	 *
	 * @since 	3.6
	 * @version 4.0
	 *
	 * @return 	array
	 */
	public static function get_options() {
		// Default empty.
		$options = [];
		$context = '';
		$post_tp = get_post_type();

		if( ! post_type_supports( $post_tp, 'wecodeart-post-info' ) ) {
			return;
		}

		$types = wecodeart( 'public_post_types' );

		if( is_singular( $types ) ) {
			$options = get_theme_mod( 'content-entry-meta-' . $post_tp . '-singular' );
			$context = 'single';
		}

		if( is_post_type_archive( $types ) || wecodeart_if( 'is_post_archive' ) ) {
			$options = get_theme_mod( 'content-entry-meta-' . $post_tp . '-archive' );
			$context = 'archive';
		}

		return apply_filters( 'wecodeart/filter/entry/meta/get_options', $options, $context );  
	}

	/**
	 * This function holds our Meta Modules
	 *
	 * @since	3.6
	 * @version	3.9.7
	 *
	 * @return 	array
	 */
	public static function modules() {
		$defaults = [
			'author' => [
				'label'    => esc_html__( 'Author', 'wecodeart' ),
				'callback' => [ __CLASS__, 'author' ]
			],
			'date' => [
				'label'    => esc_html__( 'Date', 'wecodeart' ),
				'callback' => [ __CLASS__, 'date' ]
			],
			'categories' => [
				'label'    => esc_html__( 'Categories', 'wecodeart' ),
				'callback' => [ __CLASS__, 'categories' ]
			],
			'tags' => [
				'label'    => esc_html__( 'Tags', 'wecodeart' ),
				'callback' => [ __CLASS__, 'tags' ]
			],
			'comments' => [
				'label'    => esc_html__( 'Comments', 'wecodeart' ),
				'callback' => [ __CLASS__, 'comments' ]
			],
			'edit' => [
				'label'    => esc_html__( 'Edit Link', 'wecodeart' ),
				'callback' => [ __CLASS__, 'edit_link' ]
			]
		];

		// Return Modules.
		$defaults = apply_filters( 'wecodeart/filter/entry/meta/modules', $defaults );

		// Supported Modules
		$defaults = array_filter( $defaults, function( $item ) {
			return in_array( $item, current( get_theme_support( 'meta-modules' ) ) );
		}, ARRAY_FILTER_USE_KEY );

		return $defaults;
	}

	/**
	 * Return the Entry Meta HTML with modules selected by user
	 * 
	 * @uses	Markup::wrap()
	 *
	 * @since	3.6
	 * @version	4.2
	 *
	 * @return 	void
	 */
	public static function render() {
		// Do dont return on CPT Without Support.
		if( ! post_type_supports( get_post_type(), 'wecodeart-post-info' ) ) {
			return;
		}

		Markup::wrap( 'entry-meta', [ [ 
			'tag' 	=> 'div', 
			'attrs' => [ 
				'class' => 'entry-meta mb-4' 
			]
		] ], [ 'WeCodeArt\Markup', 'sortable' ], [ self::modules(), self::get_options() ] ); 
	}
}