<?php
/**
 * WeCodeArt Framework.
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package 	WeCodeArt Framework
 * @subpackage 	Core\Entry\Meta
 * @copyright   Copyright (c) 2019, WeCodeArt Framework
 * @since 		3.6
 * @version		3.9.5
 */

namespace WeCodeArt\Core\Entry;

defined( 'ABSPATH' ) || exit();

use WeCodeArt\Utilities\Markup;
use WeCodeArt\Utilities\Markup\SVG;
use WeCodeArt\Utilities\Callbacks;

/**
 * Handles Entry Meta output
 */
class Meta {

	use \WeCodeArt\Singleton;

	/**
	 * Send to Constructor
	 * @since 3.6.4
	 */
	public function init() {
		add_action( 'wecodeart/hook/entry/header', [ $this, 'render' ], 30 ); 
	}
	
	/**
	 * Entry Meta Author Template
	 *
	 * @since	1.0
	 * @version	3.9.5
	 *
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function author( $author_id = 0, $echo = true ) {
		
		$author_id 	= $author_id ?: get_the_author_meta( 'ID' );
		$author		= get_the_author_meta( 'display_name', $author_id );
		$author_url = get_author_posts_url( $author_id );

		// In order to render something when ajax refreshed in customizer.
		$author_name = $author ? $author : esc_html__( 'Author Name', wecodeart_config( 'textdomain' ) );
		
		Markup::template( 'entry/meta/author', [
			'author_id'		=> $author_id,
			'author_url'	=> $author_url,
			'author_name'	=> $author_name,
		], $echo );
	}

	/**
	 * Entry Meta Date Template
	 *
	 * @since	1.0
	 * @version	3.9.5
	 *
	 * @param 	array	$args
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function date( $args = [], $echo = true ) {
		$defaults = [
			'published'		=> [
				'robot'	=> get_the_date( DATE_W3C ),
				'human' => get_the_date()
			],
		];

		if ( get_the_time( 'U' ) !== get_the_modified_time( 'U' ) ) {
			$defaults = wp_parse_args( [
				'modified' => [
					'robot'	=> get_the_modified_date( DATE_W3C ),
					'human' => get_the_modified_date()
				],
			], $defaults );
		}

		$args = wp_parse_args( $args, $defaults );

		Markup::template( 'entry/meta/date', $args, $echo );
	} 

	/**
	 * Entry Meta Categories Template
	 *
	 * @since	1.0
	 * @version	3.9.5
	 * 
	 * @param 	array	$args
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function categories( $args = [], $echo = true ) {
		// Set the defaults
		$defaults = [
			'before' 	=> SVG::compile( 'folders' ),
			'after'  	=> '&nbsp;',
			'sr_text'	=> esc_html__( 'Posted in ', wecodeart_config( 'textdomain' ) ),
			'sep'    	=> ', ',
		];

		$args = wp_parse_args( $args, apply_filters( 'wecodeart/filter/entry/meta/cats/defaults', $defaults ) );

		// Get what we need
		$primary_cat = get_post_meta( get_the_ID(), '_yoast_wpseo_primary_category', true );
		if( $primary_cat ) {
			$cats = sprintf( 
				'<a href="%s" rel="category tag">%s</a>', 
				esc_url( get_category_link( $primary_cat ) ),
				esc_html( get_term_by( 'id', $primary_cat, 'category' )->name )
			);

			$args = wp_parse_args( [
				'before' => SVG::compile( 'folder' )
			], $args );
		} else {
			$cats = get_the_category_list( $args['sep'] );
		}

		// Do nothing if no cats
		if ( ! $cats ) {
			return;
		}

		// The HTML
		$output = apply_filters( 'wecodeart/filter/entry/meta/cats/html', sprintf( 
				/* translators: %s: post cats */
				__( '<span class="entry-cats">%1$s %2$s %3$s %4$s</span>', wecodeart_config( 'textdomain' ) ), 
				$args[ 'before' ], 
				'<span class="screen-reader-text">' . esc_html( $args['sr_text'] ) . '</span>',
				$cats, 
				$args[ 'after' ] 
			), $args
		);

		if ( $echo ) {
			echo $output;
			return;
		}

		return $output;
	}

	/**
	 * Entry Meta Tags Template
	 *
	 * @since	1.0
	 * @version	3.9.5
	 *
	 * @param 	array	$args
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function tags( $args = [], $echo = true ) {
		// Do nothing if no tags
		if ( empty( get_the_tags() ) ) {
			return;
		}

		Markup::template( 'entry/meta/tags', wp_parse_args( $args, [
			'post_id' 	=> get_the_ID(),
			'separator' => ', ',
		] ), $echo );
	} 

	/**
	 * Entry Meta Comments Template
	 *
	 * @since	1.0
	 * @version	3.9.5
	 * 
	 * @param 	array	$args
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function comments( $args = [], $echo = true ) {
		// Only if post type supports
		if ( ! post_type_supports( get_post_type(), 'comments' ) ) {
			return;
		}

		// Show only where comments are enabled or have comments (even if disabled)
		if ( ! comments_open() && true === (bool) apply_filters( 'wecodeart/filter/entry/meta/comments/hide_if_off', true ) ) { 
			return;
		}

		$number     = (int) get_comments_number( get_the_ID() );

		$classnames = [ 'entry-comments' ];

		if( 0 === $number ) {
			$classnames[] = 'entry-comments--none';
		} elseif ( 1 === $number ) {
			$classnames[] = 'entry-comments--one';
		} elseif ( 1 < $number ) {
			$classnames[] = 'entry-comments--multiple';
		}
		
		if( post_password_required() ) {
			$classnames[] = 'entry-comments--protected';
		}

		Markup::template( 'entry/meta/comments', wp_parse_args( $args, [
			'classname'	=> esc_attr( implode( ' ', $classnames ) ),
			'i18n' 		=> [
				'more'        	=> esc_html__( '% Comments', 			wecodeart_config( 'textdomain' ) ),
				'one'         	=> esc_html__( '1 Comment', 			wecodeart_config( 'textdomain' ) ),
				'zero'        	=> esc_html__( 'Leave a Comment', 		wecodeart_config( 'textdomain' ) ),
				'closed'		=> esc_html__( 'Comments are Closed', 	wecodeart_config( 'textdomain' ) )
			]
		] ), $echo );
	}

	/**
	 * Entry Meta Edit Template
	 *
	 * @since	1.0
	 * @version	3.9.5
	 *
	 * @param 	array	$args
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function edit_link( $args = [], $echo = true ) {
		if( ! is_user_logged_in() ) {
			return;
		}
		
		Markup::template( [ 'entry/meta/edit', 'link' ], wp_parse_args( $args, [
			'post_id' => get_the_ID(),
			'i18n' => [
				'text'	=> esc_html__( 'Edit', wecodeart_config( 'textdomain' ) ),
			],
		] ), $echo );
	}

	/**
	 * Entry Meta Read More Template
	 *
	 * @since	1.0
	 * @version	3.9.5
	 *
	 * @param 	array	$args
	 * @param 	bool	$echo
	 *
	 * @return 	string
	 */
	public static function read_more( $args = [], $echo = true ) {
		Markup::template( [ 'entry/meta/read', 'more' ], wp_parse_args( $args, [
			'permalink'	=> get_the_permalink(),
			'title'		=> get_the_title(),
			'post_id' 	=> get_the_ID(),
		] ), $echo );
	}

	/**
	 * Get Contextual options
	 *
	 * @since 	3.6
	 * @version 3.9.5
	 *
	 * @return 	array
	 */
	public static function get_options() {
		// Default empty
		$options = [];
		$context = '';

		foreach( wecodeart( 'public_post_types' ) as $type ) { 
			// Post option preffix
			$theme_mod =  'content-entry-meta-' . $type;

			if( is_singular( $type ) ) {
				$options = get_theme_mod( $theme_mod . '-singular' );
				$context = 'single';
			}

			if( is_post_type_archive( $type ) ) {
				$options = get_theme_mod( $theme_mod . '-archive' );
				$context = 'archive';
			}

			if( $type === 'post' && Callbacks::is_post_archive() ) {
				$options = get_theme_mod( $theme_mod . '-archive' );
				$context = 'archive';
			}
		}

		return apply_filters( 'wecodeart/filter/entry/meta/get_options', $options, $context );  
	}

	/**
	 * This function holds our Meta Modules
	 *
	 * @since	3.6
	 * @version	3.9.5
	 *
	 * @return 	array
	 */
	public static function modules() {
		$defaults = [
			'author' => [
				'label'    => esc_html__( 'Author', wecodeart_config( 'textdomain' ) ),
				'callback' => [ __CLASS__, 'author' ]
			],
			'date' => [
				'label'    => esc_html__( 'Date', wecodeart_config( 'textdomain' ) ),
				'callback' => [ __CLASS__, 'date' ]
			],
			'categories' => [
				'label'    => esc_html__( 'Categories', wecodeart_config( 'textdomain' ) ),
				'callback' => [ __CLASS__, 'categories' ]
			],
			'tags' => [
				'label'    => esc_html__( 'Tags', wecodeart_config( 'textdomain' ) ),
				'callback' => [ __CLASS__, 'tags' ]
			],
			'comments' => [
				'label'    => esc_html__( 'Comments', wecodeart_config( 'textdomain' ) ),
				'callback' => [ __CLASS__, 'comments' ]
			],
			'edit' => [
				'label'    => esc_html__( 'Edit Link', wecodeart_config( 'textdomain' ) ),
				'callback' => [ __CLASS__, 'edit_link' ]
			]
		];
		
		// Return Modules
		return apply_filters( 'wecodeart/filter/entry/meta/modules', $defaults ); 
	}

	/**
	 * Return the Entry Meta HTML with modules selected by user
	 * 
	 * @uses	Markup::wrap()
	 *
	 * @since	3.6
	 * @version	3.9.5
	 *
	 * @return 	void
	 */
	public static function render() {
		// Do dont return on CPT Without Support.
		if( ! post_type_supports( get_post_type(), 'wecodeart-post-info' ) ) return; 

		Markup::wrap( 'entry-meta', [ [ 
				'tag' 	=> 'div', 
				'attrs' => [ 
					'class' => 'entry-meta' 
				]
			] ], 
			[ 'WeCodeArt\Utilities\Markup', 'sortable' ],
			[ self::modules(), self::get_options() ]
		); 
	}
}