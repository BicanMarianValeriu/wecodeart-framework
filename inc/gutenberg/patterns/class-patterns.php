<?php
/**
 * WeCodeArt Framework
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package		WeCodeArt Framework
 * @subpackage  Gutenberg Patterns
 * @copyright   Copyright (c) 2024, WeCodeArt Framework
 * @since		5.0.0
 * @version		6.5.2
 */

namespace WeCodeArt\Gutenberg;

defined( 'ABSPATH' ) || exit;

use WeCodeArt\Singleton;

/**
 * Handles Gutenberg Theme Patterns Functionality.
 */
class Patterns {

	use Singleton;

	/**
	 * Folder.
	 *
	 * @var string
	 */
	const FOLDER = 'patterns';

	/**
	 * The indexed patterns.
	 *
	 * @var 	array
	 */
	private $patterns	= [];

	/**
	 * Init
	 *
	 * @since 	5.0.0
	 *
	 * @return 	void
	 */
	public function init() {
		// Register.
		$this->register_categories();
		$this->register_patterns();

		\add_action( 'admin_menu', [ $this, 'register_menu' ], 20, 1 );
	}

	/**
	 * Add Reusable menu
	 *
	 * @return void
	 */
	public function register_menu(): void {
		\add_submenu_page(
			'themes.php',
			esc_html__( 'Patterns', 'wecodeart' ),
			esc_html__( 'Patterns', 'wecodeart' ),
			'manage_options',
			'site-editor.php?postType=wp_block',
			'',
			1
		);
	}

	/**
	 * Register block patterns categories.
	 *
	 * @return 	void
	 */
	public function register_categories() {
		$data 		= [];
		$themes     = [];
		$stylesheet = get_stylesheet();
		$template   = get_template();

		if ( $stylesheet !== $template ) {
			$themes[] = wp_get_theme( $stylesheet );
		}

		$themes[] = wp_get_theme( $template );
		
		foreach ( $themes as $theme ) {
			$dir	= $theme->get_stylesheet_directory();
			$file	= wp_normalize_path( $dir . DIRECTORY_SEPARATOR . self::FOLDER . DIRECTORY_SEPARATOR . '_categories.json' );
			if ( file_exists( $file ) ) {
				$data = array_merge( $data, json_decode( file_get_contents( $file ), true ) );
			}
		}

		if( empty( $data ) ) return;

		( new Patterns\Categories( $data ) )->register();
	}

	/**
	 * Register block patterns.
	 *
	 * @return 	void
	 */
	public function register_patterns() {
		$themes     = [];
		$stylesheet = get_stylesheet();
		$template   = get_template();

		if ( $stylesheet !== $template ) {
			$themes[] = wp_get_theme( $stylesheet );
		}

		$themes[] = wp_get_theme( $template );

		foreach ( $themes as $theme ) {
			$dir		= $theme->get_stylesheet_directory();
			$dirpath 	= wp_normalize_path( $dir . DIRECTORY_SEPARATOR . self::FOLDER . DIRECTORY_SEPARATOR );

			// Skip if not readable.
			if ( ! is_dir( $dirpath ) || ! is_readable( $dirpath ) ) {
				continue;
			}
			
			// If exists, continue.
			if ( file_exists( $dirpath ) ) {
				// Merge index data if exists.
				$index	= $dirpath . '_index.json';
				if ( file_exists( $index ) ) {
					$this->patterns = array_merge( $this->patterns, json_decode( file_get_contents( $index ), true ) );
				}
				// Loop HTML files and register.
				$files = glob( $dirpath . '*.html' );
				if ( $files ) {
					foreach ( $files as $file ) {
						$this->register_from_file( wp_parse_args( [
							'theme' => $theme->get( 'TextDomain' ),
							'path' 	=> $file,
						], 	pathinfo( $file ) ) );
					}
				}
			}
		}
	}

	/**
	 * Build a unified template object based on a theme file.
	 *
	 * @param 	array 	$file 	Theme file.
	 *
	 * @return 	Patterns\Pattern Template.
	 */
	public function register_from_file( $file ) {
		$args = [
			'title' 	=> ucwords( implode( ' ', explode( '-', $file['filename'] ) ) ),
			'content' 	=> file_get_contents( $file['path'] ),
			'slug'		=> $file['filename'],
			'theme'		=> $file['theme'],
		];

		$has_json = current( wp_list_filter( $this->patterns, [ 'slug' => $args['slug'] ] ) );
		
		if( $has_json ) {
			$args = wp_parse_args( $has_json, $args );
		}

		return ( new Patterns\Pattern( $args ) )->register();
	}
}
