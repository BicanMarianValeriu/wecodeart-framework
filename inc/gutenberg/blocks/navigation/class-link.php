<?php
/**
 * WeCodeArt Framework
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package		WeCodeArt Framework
 * @subpackage  Gutenberg\Blocks
 * @copyright   Copyright (c) 2021, WeCodeArt Framework
 * @since		5.0.0
 * @version		5.0.0
 */

namespace WeCodeArt\Gutenberg\Blocks\Navigation;

defined( 'ABSPATH' ) || exit();

use WeCodeArt\Markup;
use WeCodeArt\Singleton;
use WeCodeArt\Support\Styles;
use WeCodeArt\Gutenberg\Blocks\Dynamic;
use function WeCodeArt\Functions\get_prop;

/**
 * Gutenberg Navigation Link block.
 */
class Link extends Dynamic {

	use Singleton;

	/**
	 * Block namespace.
	 *
	 * @var string
	 */
	protected $namespace = 'core';

	/**
	 * Block name.
	 *
	 * @var string
	 */
	protected $block_name = 'navigation-link';

	/**
	 * Shortcircuit Register
	 */
	public function register_block_type() {
		add_filter( 'block_type_metadata_settings', [ $this, 'filter_render' ], 10, 2 );
	}

	/**
	 * Filter table markup
	 *
	 * @param	array 	$settings
	 * @param	array 	$data
	 */
	public function filter_render( $settings, $data ) {
		if ( $this->get_block_type() === $data['name'] ) {
			$settings = wp_parse_args( [
				'render_callback' => [ $this, 'render' ]
			], $settings );
		}
		
		return $settings;
	}

	/**
	 * Dynamically renders the `core/navigation-link` block.
	 *
	 * @param 	array 	$attributes The block attributes.
	 *
	 * @return 	string 	The block markup.
	 */
	public function render( $attributes = [], $content = '', $block = null ) {
		$link_has_id 	= isset( $attributes['id'] ) && is_numeric( $attributes['id'] );
		$is_post_type	= isset( $attributes['kind'] ) && 'post-type' === $attributes['kind'];
		$is_post_type	= $is_post_type || isset( $attributes['type'] ) && ( 'post' === $attributes['type'] || 'page' === $attributes['type'] );

		// Don't render the block's subtree if it is a draft.
		if ( $is_post_type && $link_has_id ) {
			$post = get_post( $attributes['id'] );
			if ( 'publish' !== $post->post_status ) {
				return '';
			}
		}

		// Don't render the block's subtree if it has no label.
		if ( empty( $attributes['label'] ) ) {
			return '';
		}

		$has_submenu 	= count( $block->inner_blocks ) > 0;
		$is_active   	= ! empty( $attributes['id'] ) && ( (int) get_the_ID() === (int) $attributes['id'] );
		
		$classes		= [ 'wp-block-navigation-link', 'nav-item' ];
		$class_name 	= ! empty( $attributes['className'] ) ? implode( ' ', (array) $attributes['className'] ) : false;

		// Fallback - to do, if styles extension is disabled.
		$inline_style 	= '';

		if ( false !== $class_name ) {
			$classes[] = $class_name;
		}

		if( $has_submenu ) {
			$classes[] = 'dropdown';
		}

		$link_classes 	= array();
		$icon_classes	= array();

		// Get an updated $classes array without linkmod or icon classes.
		$classes = $this->pluck_special_classes( $classes, $link_classes, $icon_classes );

		return Markup::wrap( 'nav-item', [ [
			'tag' 	=> 'li',
			'attrs'	=> [
				'class'	=> join( ' ', $classes ),
				'style'	=> $inline_style,
			]
		] ], function( $attributes, $block, $is_active, $has_submenu, $link_classes, $icon_classes ) {
			$classes = [ 'wp-block-navigation-link__content', 'nav-link' ];
			if( $is_active ) {
				$classes[] = 'active';
			}
			
			if( $has_submenu ) {
				$classes[] = 'dropdown-toggle';
			}

			$linkmod_type 	= $this->get_linkmod_type( $link_classes );
			$attrs 			= $this->update_attrs_for_linkmod_type( [
				'class' 	=> join( ' ', $classes ),
				'href'		=> get_prop( $attributes, 'url', null ),
				'target' 	=> get_prop( $attributes, 'opensInNewTab' ) === true ? '_blank' : null,
				'rel'		=> get_prop( $attributes, 'rel', get_prop( $attributes, 'nofollow', null ) === 'nofollow' ? 'nofollow' : null ),
				'title'		=> get_prop( $attributes, 'title', null ),
				'data-bs-toggle' 	=> $has_submenu ? 'dropdown' : null,
				'data-bs-auto-close'=> $has_submenu ? 'outside' : null,
				'aria-haspopup' 	=> $has_submenu ? 'true' : null,
				'aria-expanded' 	=> $has_submenu ? 'false' : null,
				'aria-current'		=> $is_active ? 'page' : null,
			], $link_classes );

			// Nav Link
			Markup::wrap( 'nav-link', [ [
				'tag' 	=> $this->get_linkmod_tag( $linkmod_type ),
				'attrs'	=> $attrs,
			] ], function( $attributes, $is_active, $icon_classes ) {
				// Icon
				$icon_classname = join( ' ', $icon_classes );
				if ( ! empty( $icon_classname ) ) { ?>
				<span class="wp-block-navigation-link__icon me-1">
					<i class="<?php echo esc_attr( $icon_classname ); ?>" aria-hidden="true"></i>
				</span>
				<?php
				}

				// Label
				Markup::wrap( 'nav-label', [ [
					'tag' 	=> 'span',
					'attrs'	=> [
						'class' => 'wp-block-navigation-link__label'
					]
				] ], function( $attributes ) {
					if ( isset( $attributes['label'] ) ) {
						echo wp_kses( $attributes['label'], [
							'code'   => [],
							'em'     => [],
							'img'    => [
								'scale' => [],
								'class' => [],
								'style' => [],
								'src'   => [],
								'alt'   => [],
							],
							's'      => [],
							'span'   => [
								'style' => [],
							],
							'strong' => [],
						] );
					}
				}, [ $attributes ] );
			}, [ $attributes, $is_active, $icon_classes ] );

			// Nav Submenu
			if ( $has_submenu ) {
				$classes 	= [ 'wp-block-navigation-link__container', 'dropdown-menu' ];
				$inner_html = '';
				foreach ( $block->inner_blocks as $inner_block ) $inner_html .= $inner_block->render();
				$inner_html = str_replace( 'nav-item ', '', $inner_html );
				$inner_html = str_replace( 'nav-link', 'dropdown-item', $inner_html );

				// Background Lightness
				$palette 	= wecodeart_json( [ 'settings', 'color', 'palette', 'theme' ], [] );
				$palette 	= wecodeart_json( [ 'settings', 'color', 'palette', 'user' ], $palette );
				$background = get_prop( $block->context, [ 'style', 'color', 'background' ] );

				// If not custom, get named
				if( $background === null ) {
					$background = get_prop( $block->context, 'backgroundColor', $background );
					$background	= get_prop( current( wp_list_filter( $palette, [
						'slug' => $background,
					] ) ), 'color', false );
				}

				// If not named, get body @todo
				if( $background === false ) {
					$background = '#363636';
				}
				
				if( ( Styles::color_lightness( $background ?: '#ffffff' ) < 380 ) ) {
					$classes[] = 'dropdown-menu-dark';
				}

				Markup::wrap( 'nav-dropdown', [ [
					'tag' 	=> 'ul',
					'attrs'	=> [
						'class' => join( ' ', $classes ),
					]
				] ], $inner_html );
			}
		}, [ $attributes, $block, $is_active, $has_submenu, $link_classes, $icon_classes ], false );
	}

	/**
	 * Find any custom linkmod or icon classes and store in their holder.
	 *
	 * Supported linkmods: .disabled, .dropdown-header, .dropdown-divider, .sr-only
	 * Supported iconsets: Font Awesome 4/5, Glypicons
	 *
	 * @since 5.0.0
	 *
	 * @param array   $classes         an array of classes currently assigned to the item.
	 * @param array   $link_classes an array to hold linkmod classes.
	 * @param array   $icon_classes    an array to hold icon classes.
	 * @param integer $depth           an integer holding current depth level.
	 *
	 * @return array  $classes         a maybe modified array of classnames.
	 */
	public function pluck_special_classes( $classes, &$link_classes, &$icon_classes ) {
		foreach ( $classes as $key => $class ) {
			// If any special classes are found, store the class in it's
			// holder array and and unset the item from $classes.
			if ( preg_match( '/^disabled|^sr-only|^screen-reader-text/i', $class ) ) {
				$link_classes[] = $class;
				unset( $classes[ $key ] );
			} elseif ( preg_match( '/^dropdown-header|^dropdown-divider|^dropdown-item-text/i', $class ) ) {
				$link_classes[] = $class;
				unset( $classes[ $key ] );
			} elseif ( preg_match( '/^fa-(\S*)?|^fa(s|r|l|b)?(\s?)?$/i', $class ) ) {
				$icon_classes[] = $class;
				unset( $classes[ $key ] );
			} elseif ( preg_match( '/^glyphicon-(\S*)?|^glyphicon(\s?)$/i', $class ) ) {
				$icon_classes[] = $class;
				unset( $classes[ $key ] );
			}
		}

		return $classes;
	}

	/**
	 * Return a string containing a linkmod type and update $atts array
	 * accordingly depending on the decided.
	 *
	 * @since 	5.0.0
	 * @param 	array 	$link_classes array of any link modifier classes.
	 * 
	 * @return 	string	empty for default, a linkmod type string otherwise.
	 */
	public function get_linkmod_type( $link_classes = [] ) {
		$linkmod_type = '';
		// Loop through array of linkmod classes to handle their $atts.
		if ( ! empty( $link_classes ) ) {
			foreach ( $link_classes as $link_class ) {
				if ( ! empty( $link_class ) ) {
					if ( 'dropdown-header' === $link_class ) {
						$linkmod_type = 'dropdown-header';
					} elseif ( 'dropdown-divider' === $link_class ) {
						$linkmod_type = 'dropdown-divider';
					} elseif ( 'dropdown-item-text' === $link_class ) {
						$linkmod_type = 'dropdown-item-text';
					}
				}
			}
		}
		return $linkmod_type;
	}

	/**
	 * Return a string containing a linkmod span.
	 *
	 * @since 	5.0.0
	 * @param 	string 	$linkmod_type
	 * 
	 * @return 	string
	 */
	public function get_linkmod_tag( $linkmod_type ) {
		$output = 'a';
		if ( 'dropdown-header' === $linkmod_type || 'dropdown-item-text' === $linkmod_type ) $output = 'span';
		elseif ( 'dropdown-divider' === $linkmod_type ) $output = 'div';
		return $output;
	}

	/**
	 * Update the attributes of a nav item depending on the limkmod classes.
	 *
	 * @since 	5.0.0
	 *
	 * @param 	array $atts            array of atts for the current link in nav item.
	 * @param 	array $link_classes an array of classes that modify link or nav item behaviors or displays.
	 *
	 * @return 	array
	 */
	public function update_attrs_for_linkmod_type( $attrs = [], $link_classes = [] ) {
		if ( ! empty( $link_classes ) ) {
			foreach ( $link_classes as $link_class ) {
				if ( ! empty( $link_class ) ) { 
					if ( 'sr-only' !== $link_class ) $attrs['class'] .= ' ' . esc_attr( $link_class );  
					if ( 'disabled' === $link_class ) { 
						$attrs['aria-disabled'] = 'true';
						$attrs['href'] = '#';
						unset( $attrs['target'] ); 
					} elseif ( in_array( $link_class, [ 'dropdown-header', 'dropdown-divider', 'dropdown-item-text' ] ) ) {
						unset( $attrs['href'] );
						unset( $attrs['target'] );
					}
				}
			}
		}
		return $attrs;
	}
}