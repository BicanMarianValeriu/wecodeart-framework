<?php
/**
 * WeCodeArt Framework
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package		WeCodeArt Framework
 * @subpackage  Gutenberg\Blocks
 * @copyright   Copyright (c) 2021, WeCodeArt Framework
 * @since		5.0.0
 * @version		5.0.0
 */

namespace WeCodeArt\Gutenberg\Blocks;

defined( 'ABSPATH' ) || exit();

use WeCodeArt\Markup;
use WeCodeArt\Singleton;
use WeCodeArt\Support\Styles;
use WeCodeArt\Gutenberg\Blocks\Dynamic;
use function WeCodeArt\Functions\get_prop;

/**
 * Gutenberg Navigation block.
 */
class Navigation extends Dynamic {

	use Singleton;

	/**
	 * Shortcircuit Register
	 */
	public function register_block_type() {
		add_filter( 'block_type_metadata_settings', [ $this, 'filter_render' ], 10, 2 );
	}

	/**
	 * Filter table markup
	 *
	 * @param	array 	$settings
	 * @param	array 	$data
	 */
	public function filter_render( $settings, $data ) {
		if ( 'core/navigation' !== $data['name'] ) {
			return $settings;
		}

		return wp_parse_args( [
			'render_callback' => [ $this, 'render' ]
		], $settings );
	}

	/**
	 * Dynamically renders the `core/navigation` block.
	 *
	 * @param 	array 	$attributes The block attributes.
	 * @param 	string 	$content 	The block content.
	 * @param 	array 	$block 		The block data.
	 *
	 * @return 	string 	The block markup.
	 */
	public function render( $attributes = [], $content = '', $block = null ) {
		if ( $color = get_prop( $attributes, 'rgbTextColor' ) ) {
			$attributes['customTextColor'] = $color;
		}
		
		if ( $color = get_prop( $attributes, 'rgbBackgroundColor' ) ) {
			$attributes['customBackgroundColor'] = $color;
		}

		unset( $attributes['rgbTextColor'], $attributes['rgbBackgroundColor'] );

		$inner_blocks = $block->inner_blocks;

		if ( empty( $inner_blocks ) && array_key_exists( '__unstableLocation', $attributes ) ) {
			$menu_items = $this->get_menu_items_at_location( $attributes['__unstableLocation'] );
			if ( empty( $menu_items ) ) {
				return '';
			}
	
			$menu_items_by_parent_id = $this->sort_menu_items_by_parent_id( $menu_items );
			$parsed_blocks           = $this->parse_blocks_from_menu_items( $menu_items_by_parent_id[0], $menu_items_by_parent_id );
	
			// TODO - this uses the full navigation block attributes for the
			// context which could be refined.
			$inner_blocks = new \WP_Block_List( $parsed_blocks, $attributes );
		}
		
		if ( empty( $inner_blocks ) ) {
			return '';
		}

		$colors     = $this->css_colors( $attributes );
		$font_sizes = $this->css_font_sizes( $attributes );
		$classes 	= [ 'wp-block-navigation', 'navbar' ];
		$palette 	= wecodeart_json( [ 'settings', 'color', 'palette', 'theme' ], [] );
		$palette 	= wecodeart_json( [ 'settings', 'color', 'palette', 'user' ], $palette );
		$background = get_prop( $attributes, [ 'style', 'color', 'background' ] );

		if( $background === false ) {
			$background = get_prop( $attributes, 'backgroundColor', [] );
			$background	= get_prop( current( wp_list_filter( $palette, [
				'slug' => $background,
			] ) ), 'color', false );
		}
		
		$classes[] 	= ( Styles::color_lightness( $background ?: '#ffffff' ) > 380 ) ? 'navbar-light' : 'navbar-dark';

		if( get_prop( $attributes, 'orientation', false ) === 'horizontal' ) {
			$classes[] = 'navbar-expand';
		}

		if( get_prop( $attributes, 'isResponsive', false ) === true ) {
			$classes 	= array_diff( $classes, [ 'navbar-expand' ] );
			$classes[] 	= 'navbar-expand-lg';
		}
		
		if( get_prop( $attributes, 'showSubmenuIcon', false ) === false ) {
			$classes[] 	= 'hide-dropdown-icon';
		}

		if( $align = get_prop( $attributes, 'itemsJustification' ) ) {
			$classes[] = 'justify-content-' . ( $align === 'right' ? 'end' : $align );
		}

		$classes    	= array_merge( $classes, $colors['css_classes'], $font_sizes['css_classes'] );
		$block_styles 	= get_prop( $attributes, 'styles', '' );
		$block_id		= uniqid();

		$html = Markup::wrap( 'navbar-nav', [ [
			'tag' 	=> 'nav',
			'attrs'	=> [
				'class'	=> join( ' ', $classes ),
				'style'	=> $block_styles . $colors['inline_styles'] . $font_sizes['inline_styles'],
			]
		] ], function( $attributes, $inner_blocks ) use ( $block_id ) {
			$classes 	= [ 'wp-block-navigation__container', 'nav', 'navbar-nav' ];
			$wrappers 	= [
				[
					'tag' 	=> 'ul',
					'attrs' => [
						'class' => implode( ' ', $classes ),
					]
				]
			];

			if( get_prop( $attributes, 'isResponsive', false ) ===  true ) {
				$wrappers = [ [
					'tag' 	=> 'div',
					'attrs' => [
						'class' => 'offcanvas offcanvas-start',
						'id'	=> 'navbar-' . $block_id,
					]
				] ];

				wecodeart_template( 'general/toggler', [
					'id'		=> 'navbar-' . $block_id,
					'toggle' 	=> 'offcanvas',
				] );

				Markup::wrap( 'navbar-offcanvas', $wrappers, function( $inner_blocks, $classes ) {
					$html = '';
					foreach ( $inner_blocks as $inner_block ) $html .= $inner_block->render();
					wecodeart_template( 'general/offcanvas', [
						'content' => sprintf( '<ul class="%s">%s</ul>', join( ' ', $classes ), $html ),
					] );
				}, [ $inner_blocks, $classes ] );

				return;
			}

			Markup::wrap( 'navbar-inner', $wrappers, function( $inner_blocks ) {
				foreach ( $inner_blocks as $inner_block ) echo $inner_block->render();
			}, [ $inner_blocks ] );

		}, [ $attributes, $inner_blocks ], false );

		return $html;
	}

	/**
	 * Build an array with CSS classes and inline styles defining the colors
	 * which will be applied to the navigation markup in the front-end.
	 *
	 * @param  array $attributes 	Navigation block context.
	 * @return array  	 			CSS classes and inline styles.
	 */
	public function css_colors( $attributes ) {
		$colors = array(
			'css_classes'   => [],
			'inline_styles' => '',
		);
	
		// Text color.
		$has_named_text_color  = get_prop( $attributes, 'textColor', false );
		$has_custom_text_color = get_prop( $attributes, 'customTextColor', false );
	
		// If has text color.
		if ( $has_custom_text_color || $has_named_text_color ) {
			// Add has-text-color class.
			$colors['css_classes'][] = 'has-text-color';
		}
	
		if ( $has_named_text_color ) {
			// Add the color class.
			$colors['css_classes'][] = sprintf( 'has-%s-color', $has_named_text_color );
		} elseif ( $has_custom_text_color ) {
			// Add the custom color inline style.
			$colors['inline_styles'] .= sprintf( 'color: %s;', $has_custom_text_color );
		}
	
		// Background color.
		$has_named_background_color  = get_prop( $attributes, 'backgroundColor', false );
		$has_custom_background_color = get_prop( $attributes, 'customBackgroundColor', false );
	
		// If has background color.
		if ( $has_custom_background_color || $has_named_background_color ) {
			// Add has-background class.
			$colors['css_classes'][] = 'has-background';
		}
	
		if ( $has_named_background_color ) {
			// Add the background-color class.
			$colors['css_classes'][] = sprintf( 'has-%s-background-color', $has_named_background_color );
		} elseif ( $has_custom_background_color ) {
			// Add the custom background-color inline style.
			$colors['inline_styles'] .= sprintf( 'background-color: %s;', $has_custom_background_color );
		}
	
		return $colors;
	}

	/**
	 * Build an array with CSS classes and inline styles defining the font sizes
	 * which will be applied to the navigation markup in the front-end.
	 *
	 * @param  array $attributes 	Navigation block context.
	 * @return array 				Font size CSS classes and inline styles.
	 */
	public function css_font_sizes( $attributes ) {
		// CSS classes.
		$font_sizes = [
			'css_classes'   => [],
			'inline_styles' => '',
		];

		if ( $value = get_prop( $attributes, 'fontSize' ) ) {
			// Add the font size class.
			$font_sizes['css_classes'][] = sprintf( 'has-%s-font-size', $value );
		} elseif ( $value = get_prop( $attributes, 'customFontSize' ) ) {
			// Add the custom font size inline style.
			$font_sizes['inline_styles'] = sprintf( 'font-size: %spx;', $value );
		}

		return $font_sizes;
	}

	/**
	 * Returns the menu items for a WordPress menu location.
	 *
	 * @param 	string 	$location The menu location.
	 * @return 	array 	Menu items for the location.
	 */
	public function get_menu_items_at_location( $location ) {
		if ( empty( $location ) ) {
			return;
		}
		
		$locations = get_nav_menu_locations();
		if ( ! isset( $locations[ $location ] ) ) {
			return;
		}
		
		$menu = wp_get_nav_menu_object( $locations[ $location ] );
		if ( ! $menu || is_wp_error( $menu ) ) {
			return;
		}

		$menu_items = wp_get_nav_menu_items( $menu->term_id, array( 'update_post_term_cache' => false ) );

		_wp_menu_item_classes_by_context( $menu_items );

		return $menu_items;
	}

	/**
	 * Sorts a standard array of menu items into a nested structure keyed by the
	 * id of the parent menu.
	 *
	 * @param 	array 	$menu_items Menu items to sort.
	 * @return 	array 	An array keyed by the id of the parent menu where each element
	 *               	is an array of menu items that belong to that parent.
	 */
	public function sort_menu_items_by_parent_id( $menu_items ) {
		$sorted_menu_items = [];
		foreach ( (array) $menu_items as $menu_item ) {
			$sorted_menu_items[ $menu_item->menu_order ] = $menu_item;
		}
		unset( $menu_items, $menu_item );

		$menu_items_by_parent_id = [];

		foreach ( $sorted_menu_items as $menu_item ) {
			$menu_items_by_parent_id[ $menu_item->menu_item_parent ][] = $menu_item;
		}

		return $menu_items_by_parent_id;
	}

	/**
	 * Turns menu item data into a nested array of parsed blocks
	 *
	 * @param 	array $menu_items               An array of menu items that represent
	 *                                        an individual level of a menu.
	 * @param 	array $menu_items_by_parent_id  An array keyed by the id of the
	 *                                        parent menu where each element is an
	 *                                        array of menu items that belong to
	 *                                        that parent.
	 * @return 	array An array of parsed block data.
	 */
	public function parse_blocks_from_menu_items( $menu_items, $menu_items_by_parent_id ) {
		if ( empty( $menu_items ) ) {
			return [];
		}

		$blocks = [];

		foreach ( $menu_items as $menu_item ) {
			$block = [
				'blockName' => 'core/navigation-link',
				'attrs'     => [
					'label' => $menu_item->title,
					'url'   => $menu_item->url,
				],
			];

			$block['innerBlocks'] = $this->parse_blocks_from_menu_items(
				isset( $menu_items_by_parent_id[ $menu_item->ID ] )
						? $menu_items_by_parent_id[ $menu_item->ID ]
						: [],
				$menu_items_by_parent_id
			);

			$blocks[] = $block;
		}

		return $blocks;
	}
}
