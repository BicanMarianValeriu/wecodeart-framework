<?php
/**
 * WeCodeArt Framework
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package		WeCodeArt Framework
 * @subpackage  Gutenberg\Blocks
 * @copyright   Copyright (c) 2021, WeCodeArt Framework
 * @since		5.0.0
 * @version		5.0.0
 */

namespace WeCodeArt\Gutenberg\Blocks;

defined( 'ABSPATH' ) || exit();

use WeCodeArt\Markup;
use WeCodeArt\Singleton;
use WeCodeArt\Support\Styles;
use WeCodeArt\Gutenberg\Blocks\Dynamic;
use function WeCodeArt\Functions\get_prop;

/**
 * Gutenberg Navigation block.
 */
class Navigation extends Dynamic {

	use Singleton;

	/**
	 * Block namespace.
	 *
	 * @var string
	 */
	protected $namespace = 'core';

	/**
	 * Block name.
	 *
	 * @var string
	 */
	protected $block_name = 'navigation';

	/**
	 * Shortcircuit Register
	 */
	public function register() {
		add_filter( 'block_type_metadata_settings', [ $this, 'filter_render' ], 10, 2 );
	}

	/**
	 * Filter navigation markup
	 *
	 * @param	array 	$settings
	 * @param	array 	$data
	 */
	public function filter_render( $settings, $data ) {
		if ( $this->get_block_type() === $data['name'] ) {
			$settings = wp_parse_args( [
				'render_callback' => [ $this, 'render' ]
			], $settings );
		}
		
		return $settings;
	}

	/**
	 * Dynamically renders the `core/navigation` block.
	 *
	 * @param 	array 	$attributes The block attributes.
	 * @param 	string 	$content 	The block content.
	 * @param 	array 	$block 		The block data.
	 *
	 * @return 	string 	The block markup.
	 */
	public function render( $attributes = [], $content = '', $block = null ) {
		if ( $color = get_prop( $attributes, 'rgbTextColor' ) ) {
			$attributes['customTextColor'] = $color;
		}
		
		if ( $color = get_prop( $attributes, 'rgbBackgroundColor' ) ) {
			$attributes['customBackgroundColor'] = $color;
		}

		unset( $attributes['rgbTextColor'], $attributes['rgbBackgroundColor'] );

		$inner_blocks = $block->inner_blocks;

		if ( empty( $inner_blocks ) && array_key_exists( '__unstableLocation', $attributes ) ) {
			$menu_items = $this->get_menu_items( $attributes['__unstableLocation'] );
			if ( empty( $menu_items ) ) {
				return '';
			}
	
			$sorted_items 	= $this->sort_menu( $menu_items );
			$parsed_blocks 	= $this->parse_menu( $sorted_items[0], $sorted_items );
			$inner_blocks 	= new \WP_Block_List( $parsed_blocks, $attributes );
		}
		
		if ( empty( $inner_blocks ) ) {
			return '';
		}

		$colors     = $this->css_colors( $attributes );
		$font_sizes = $this->css_font_sizes( $attributes );
		$background = self::get_background( $attributes );

		$classes 	= [ 'wp-block-navigation', 'navbar' ];
		$classes[] 	= ( Styles::color_lightness( $background ) < 380 ) ? 'navbar-dark' : 'navbar-light';

		if( get_prop( $attributes, 'orientation', false ) === 'horizontal' ) {
			$classes[] = 'navbar-expand';
		}

		if( get_prop( $attributes, 'isResponsive', false ) === true ) {
			$classes 	= array_diff( $classes, [ 'navbar-expand' ] );
			$classes[] 	= 'navbar-expand-lg';
		}
		
		if( get_prop( $attributes, 'showSubmenuIcon', false ) === false ) {
			$classes[] 	= 'hide-dropdown-icon';
		}

		if( $align = get_prop( $attributes, 'itemsJustification' ) ) {
			$classes[] = 'justify-content-' . ( $align === 'right' ? 'end' : $align );
		}

		$classes    	= array_merge( $classes, $colors['css_classes'], $font_sizes['css_classes'] );
		$block_styles 	= get_prop( $attributes, 'styles', '' );
		$block_id		= uniqid();

		$html = Markup::wrap( 'navbar-nav', [ [
			'tag' 	=> 'nav',
			'attrs'	=> [
				'class'	=> join( ' ', $classes ),
				'style'	=> $block_styles . $colors['inline_styles'] . $font_sizes['inline_styles'],
			]
		] ], function( $attributes, $inner_blocks ) use ( $block_id ) {
			$classes 	= [ 'wp-block-navigation__container', 'nav', 'navbar-nav' ];
			$wrappers 	= [
				[
					'tag' 	=> 'ul',
					'attrs' => [
						'class' => implode( ' ', $classes ),
					]
				]
			];

			if( get_prop( $attributes, 'isResponsive', false ) ===  true ) {
				$wrappers = [ [
					'tag' 	=> 'div',
					'attrs' => [
						'class' => join( ' ', [ 'offcanvas', 'offcanvas-start' ] ),
						'id'	=> 'navbar-' . $block_id,
					]
				] ];

				wecodeart_template( 'general/toggler', [
					'id'		=> 'navbar-' . $block_id,
					'toggle' 	=> 'offcanvas',
				] );

				Markup::wrap( 'navbar-offcanvas', $wrappers, function( $inner_blocks, $classes ) {
					$html = '';
					foreach ( $inner_blocks as $inner_block ) $html .= $this->render_menu_block( $inner_block );
					wecodeart_template( 'general/offcanvas', [
						'content' => sprintf( '<ul class="%s">%s</ul>', join( ' ', $classes ), $html ),
					] );
				}, [ $inner_blocks, $classes ] );

				return;
			}

			Markup::wrap( 'navbar-inner', $wrappers, function( $inner_blocks ) {
				foreach ( $inner_blocks as $inner_block ) echo $this->render_menu_block( $inner_block );
			}, [ $inner_blocks ] );

		}, [ $attributes, $inner_blocks ], false );

		return $html;
	}

	/**
	 * Renders menu item wrapper.
	 *
	 * @param 	object 	$block.
	 *
	 * @return 	string 	Rendered block with wrapper block
	 */
	public function render_menu_block( $block ) {
		$html = $block->render();
		
		// For this specific blocks, please wrap them in a <li> for valid markup
		if( in_array( get_prop( $block->parsed_block, 'blockName', '' ), [
			'core/search',
			'core/social-links',
			'core/site-title',
			'core/site-logo'
		] ) ) {
			$classes	= [ 'wp-block-navigation-link', 'nav-item' ];
			$classes[]  = 'nav-item--' . join( '-', explode( '/', get_prop( $block->parsed_block, 'blockName' ) ) );

			return Markup::wrap( 'nav-item', [ [
				'tag' 	=> 'li',
				'attrs'	=> [
					'class'	=> join( ' ', $classes ),
				]
			] ], $html, [], false );
		}

		return $html;
	}

	/**
	 * Returns the menu items for a WordPress menu location.
	 *
	 * @param 	string 	$location The menu location.
	 * @return 	array 	Menu items for the location.
	 */
	public function get_menu_items( $location ) {
		if ( empty( $location ) ) {
			return;
		}
		
		$locations = get_nav_menu_locations();
		if ( ! isset( $locations[ $location ] ) ) {
			return;
		}
		
		$menu = wp_get_nav_menu_object( $locations[ $location ] );
		if ( ! $menu || is_wp_error( $menu ) ) {
			return;
		}

		$menu_items = wp_get_nav_menu_items( $menu->term_id, [ 'update_post_term_cache' => false ] );

		_wp_menu_item_classes_by_context( $menu_items );

		return $menu_items;
	}

	/**
	 * Sorts a standard array of menu items into a nested structure keyed by the
	 * id of the parent menu.
	 *
	 * @param 	array 	$menu_items Menu items to sort.
	 * @return 	array 	An array keyed by the id of the parent menu where each element
	 *               	is an array of menu items that belong to that parent.
	 */
	public function sort_menu( $menu_items ) {
		$sorted_menu_items = [];
		foreach ( (array) $menu_items as $menu_item ) {
			$sorted_menu_items[ $menu_item->menu_order ] = $menu_item;
		}
		unset( $menu_items, $menu_item );

		$sorted = [];

		foreach ( $sorted_menu_items as $menu_item ) {
			$sorted[ $menu_item->menu_item_parent ][] = $menu_item;
		}

		return $sorted;
	}

	/**
	 * Turns menu item data into a nested array of parsed blocks
	 *
	 * @param 	array 	$menu_items
	 * @param 	array 	$parent
	 *
	 * @return 	array	An array of parsed block data.
	 */
	public function parse_menu( $menu_items, $parent ) {
		if ( empty( $menu_items ) ) {
			return [];
		}

		$blocks = [];

		foreach ( $menu_items as $item ) {
			if( isset( $item->content ) ) {
				$block = current( parse_blocks( $item->content ) );
			} else {
				$block = [
					'blockName' => 'core/navigation-link',
					'attrs'     => [
						'id'			=> url_to_postid( $item->url ),
						'label' 		=> $item->title,
						'title' 		=> $item->attr_title,
						'url'   		=> $item->url,
						'opensInNewTab'	=> $item->target === '_blank' ? true : false,
						'className' 	=> $item->classes
					],
					'innerBlocks' => []
				];
			}

			$block['innerBlocks'] = $this->parse_menu( isset( $parent[ $item->ID ] ) ? $parent[ $item->ID ] : [], $parent );

			$blocks[] = $block;
		}

		return $blocks;
	}

	/**
	 * Get Background.
	 *
	 * @since 	5.0.0
	 * @param 	array 	$context	Block Context
	 * 
	 * @return 	string
	 */
	public static function get_background( $context ) {
		// Background Lightness
		$palette 	= wecodeart_json( [ 'settings', 'color', 'palette', 'theme' ], [] );
		$palette 	= wecodeart_json( [ 'settings', 'color', 'palette', 'user' ], $palette );
		$background = get_prop( $context, [ 'style', 'color', 'background' ] );

		// If not custom, get named
		if( $background === null ) {
			$background = get_prop( $context, 'backgroundColor', $background );
			$background	= get_prop( current( wp_list_filter( $palette, [
				'slug' => $background,
			] ) ), 'color', false );
		}

		// If not named, get body
		if( $background === false ) {
			$styles 	= wecodeart_json( [ 'styles', 'color', 'background' ], false );
			if( strpos( $styles, '#' ) === 0 ) {
				$background = $styles;
			} else {
				if( mb_strpos( $styles, '|' ) !== false ) {
					$slug = explode( '|', $styles );
					$slug = end( $slug );
				} elseif( mb_strpos( $styles, '--' ) !== false ) {
					$slug = explode( '--', $styles );
					$slug = str_replace( ')', '', end( $slug ) );
				}
				$background	= get_prop( current( wp_list_filter( $palette, [
					'slug' => $slug,
				] ) ), 'color', '#ffffff' );
			}
		}

		return $background;
	}

	/**
	 * Build an array with CSS classes and inline styles defining the colors
	 * which will be applied to the navigation markup in the front-end.
	 *
	 * @param  array $attributes 	Navigation block context.
	 * @return array  	 			CSS classes and inline styles.
	 */
	public function css_colors( $attributes ) {
		$colors = array(
			'css_classes'   => [],
			'inline_styles' => '',
		);
	
		// Text color.
		$has_named_text_color  = get_prop( $attributes, 'textColor', false );
		$has_custom_text_color = get_prop( $attributes, 'customTextColor', false );
	
		// If has text color.
		if ( $has_custom_text_color || $has_named_text_color ) {
			// Add has-text-color class.
			$colors['css_classes'][] = 'has-text-color';
		}
	
		if ( $has_named_text_color ) {
			// Add the color class.
			$colors['css_classes'][] = sprintf( 'has-%s-color', $has_named_text_color );
		} elseif ( $has_custom_text_color ) {
			// Add the custom color inline style.
			$colors['inline_styles'] .= sprintf( 'color: %s;', $has_custom_text_color );
		}
	
		// Background color.
		$has_named_background_color  = get_prop( $attributes, 'backgroundColor', false );
		$has_custom_background_color = get_prop( $attributes, 'customBackgroundColor', false );
	
		// If has background color.
		if ( $has_custom_background_color || $has_named_background_color ) {
			// Add has-background class.
			$colors['css_classes'][] = 'has-background';
		}
	
		if ( $has_named_background_color ) {
			// Add the background-color class.
			$colors['css_classes'][] = sprintf( 'has-%s-background-color', $has_named_background_color );
		} elseif ( $has_custom_background_color ) {
			// Add the custom background-color inline style.
			$colors['inline_styles'] .= sprintf( 'background-color: %s;', $has_custom_background_color );
		}
	
		return $colors;
	}

	/**
	 * Build an array with CSS classes and inline styles defining the font sizes
	 * which will be applied to the navigation markup in the front-end.
	 *
	 * @param  array $attributes 	Navigation block context.
	 * @return array 				Font size CSS classes and inline styles.
	 */
	public function css_font_sizes( $attributes ) {
		// CSS classes.
		$font_sizes = [
			'css_classes'   => [],
			'inline_styles' => '',
		];

		if ( $value = get_prop( $attributes, 'fontSize' ) ) {
			// Add the font size class.
			$font_sizes['css_classes'][] = sprintf( 'has-%s-font-size', $value );
		} elseif ( $value = get_prop( $attributes, 'customFontSize' ) ) {
			// Add the custom font size inline style.
			$font_sizes['inline_styles'] = sprintf( 'font-size: %spx;', $value );
		}

		return $font_sizes;
	}

	/**
	 * Block styles
	 *
	 * @return 	string 	The block styles.
	 */
	public function styles() {
		$breaks 	= wecodeart_json( [ 'settings', 'custom', 'breakpoints' ], [] );
		$desktop	= get_prop( $breaks, 'lg', '992px' );

		return "
		.wp-block-navigation {
			height: 100%;
		}
		.offcanvas .wp-block-navigation {
			padding-top: 0;
			padding-bottom: 0;
		}
		.wp-block-navigation.hide-dropdown-icon .dropdown-toggle::after {
			content: none;
		}
		.wp-block-navigation[class*='navbar-expand-'] .offcanvas:not([aria-modal='true']) {
			width: initial;
		}
		.wp-block-navigation.navbar-dark .btn-close {
			background-color: var(--wca-white);
		}
		.wp-block-navigation .offcanvas-start .btn-close {
			margin-left: auto;
		}
		.wp-block-navigation-link__content:not([data-bs-toggle='dropdown']):hover ~ .dropdown-menu,
		.wp-block-navigation-link__content:not([data-bs-toggle='dropdown']):focus ~ .dropdown-menu,
		.wp-block-navigation-link__content:not([data-bs-toggle='dropdown']):focus-within ~ .dropdown-menu {
			display: block;
			visibility: visible;
			opacity: 1;
		}
		.wp-block-navigation-link__content.nav-link,
		.wp-block-navigation-link__content.dropdown-item {
			display: flex;
			align-items: center;
		}
		.wp-block-navigation-link__label {
			flex: 1 1 auto;
			word-break: normal;
			overflow-wrap: break-word;
		}
		.wp-block-navigation .dropdown-menu .dropdown-menu {
			top: 0;
			left: 100%;
		}
		@media (min-width: $desktop) {
			.wp-block-navigation .dropdown-menu .dropdown-toggle::after {
				transform: rotate(270deg);
			}
		}
		@media (max-width: 991px) {
			.wp-block-navigation.navbar-dark .offcanvas {
				background-color: var(--wca-dark);
			}
		}
		";
	}
}
