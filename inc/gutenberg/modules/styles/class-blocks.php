<?php
/**
 * WeCodeArt Framework
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package		WeCodeArt Framework
 * @subpackage  Gutenberg CSS Frontend
 * @copyright   Copyright (c) 2022, WeCodeArt Framework
 * @since		5.0.0
 * @version		5.6.9
 */

namespace WeCodeArt\Gutenberg\Modules\Styles;

defined( 'ABSPATH' ) || exit();

use WeCodeArt\Support\Styles\Processor;
use function WeCodeArt\Functions\get_prop;

/**
 * Block CSS Processor
 *
 * This class handles all the Gutenberg Core styles from attributes found under style object or theme customs.
 * Any extends of this class, should use process_extra() method for extending the attributes processor.
 */
class Blocks extends Processor {

	/**
	 * Block Name.
	 *
	 * @var 	string
	 */
	protected 	$name 		= '';
	protected 	$element 	= '';

	/**
	 * Block Attrs.
	 *
	 * @var 	array
	 */
	protected 	$attrs = [];

	/**
	 * The class constructor.
	 *
	 * @access 	public
	 * @param 	array 	$args The block args.
	 */
	public function __construct( $args ) {
		$this->name		= get_prop( $args, 'blockName' );
		$this->attrs	= get_prop( $args, 'attrs', [] );
		$this->element  = wp_unique_id( '.css-' );

		// Process CSS
		$this->process_attributes();
		
		if( method_exists( $this, 'process_extra' ) ) {
			// Extra attributes
			$this->process_extra();
		}

		// Parse CSS
		$this->parse_output();
		$this->parse_custom();
	}

	/**
	 * Parses attributes and creates the styles array for them.
	 *
	 * @return 	void
	 */
	protected function process_attributes() {
		$this->output = [];

		$output 			= [];
		$output['element'] 	= apply_filters( 'wecodeart/filter/gutenberg/styles/element', $this->element, $this->name );
	
		// Inline Style
		if( $css_style = get_prop( $this->attrs, 'style' ) ) {
			// Typography
			if ( $typography = get_prop( $css_style, 'typography' ) ) {
				if ( $value = get_prop( $typography, 'fontSize' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'font-size',
						'value'	  	=> $value,
					], $output );
				}
	
				if ( $value = get_prop( $typography, 'fontWeight' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'font-weight',
						'value'	  	=> $value
					], $output );
				}

				if ( $value = get_prop( $typography, 'fontStyle' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'font-style',
						'value'	  	=> $value
					], $output );
				}
				
				if ( $value = get_prop( $typography, 'lineHeight' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'line-height',
						'value'	  	=> $value,
					], $output );
				}
	
				if ( $value = get_prop( $typography, 'textTransform' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'text-transform',
						'value'	  	=> $value
					], $output );
				}
	
				if ( $value = get_prop( $typography, 'textDecoration' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'text-decoration',
						'value'	  	=> $value
					], $output );
				}
				
				if ( $value = get_prop( $typography, 'letterSpacing' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'letter-spacing',
						'value'	  	=> $value
					], $output );
				}
			}

			// Colors
			if ( $color = get_prop( $css_style, 'color' ) ) {
				// Text
				if ( $value = get_prop( $color, 'text' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'color',
						'value'	  	=> $value
					], $output );
				}

				// Background
				if ( $value = get_prop( $color, 'background' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'background-color',
						'value'	  	=> $value
					], $output );
				}

				// Gradient
				if ( $value = get_prop( $color, 'gradient' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'background-image',
						'value'	  	=> $value
					], $output );
				}
				
				// Duotone - temporary disable until I combine them into our styles
				if ( $value = get_prop( $color, 'duotone' ) ) {
					$block_type = \WP_Block_Type_Registry::get_instance()->get_registered( $this->name );

					$duotone_support = false;
					if ( $block_type && property_exists( $block_type, 'supports' ) ) {
						$duotone_support = get_prop( $block_type->supports, [ 'color', '__experimentalDuotone' ], false );
					}

					if( $duotone_support ) {
						$this->output[] = wp_parse_args( [
							'element'	=> implode( ', ', array_map( function ( $selector ) {
								return implode( ' ', [ $this->element, trim( $selector ) ] );
							}, explode( ',', $duotone_support ) ) ),
							'property' 	=> 'filter',
							'value'	  	=> sprintf( 'url(#wp-duotone-%s)', ltrim( $this->element, '.' ) )
						], $output );
					}
				}
			}

			// Spacing
			if ( $spacing = get_prop( $css_style, 'spacing' ) ) {
				// Padding
				if ( $padding = get_prop( $spacing, 'padding', [] ) ) {
					if( ! empty( $padding ) ) {
						if( count( $padding ) === 4 && count( array_unique( $padding ) ) === 1 ) {
							$padding = end( $padding );

							// Is WP way of saved color
							if( mb_strpos( $padding, '|' ) !== false ) {
								$padding = explode( '|', $padding );
								$padding = sprintf( 'var(--wp--preset--spacing--%s)', end( $padding ) );
							}

							$this->output[] = wp_parse_args( [
								'property' 	=> 'padding',
								'value'	  	=> $padding
							], $output );
						} else {
							foreach( $padding as $dir => $val ) {
								// Is WP way of saved color
								if( mb_strpos( $val, '|' ) !== false ) {
									$val = explode( '|', $val );
									$val = sprintf( 'var(--wp--preset--spacing--%s)', end( $val ) );
								}
								
								$this->output[] = wp_parse_args( [
									'property' 	=> 'padding-' . $dir,
									'value'	  	=> $val
								], $output );
							}
						}
					}
				}

				// Margin
				if ( $margin = get_prop( $spacing, 'margin', [] ) ) {
					if( ! empty( $margin ) ) {
						if( count( $margin ) === 4 && count( array_unique( $margin ) ) === 1 ) {
							$margin = end( $margin );
							
							// Is WP way of saved color
							if( mb_strpos( $margin, '|' ) !== false ) {
								$margin = explode( '|', $margin );
								$margin = sprintf( 'var(--wp--preset--spacing--%s)', end( $margin ) );
							}

							$this->output[] = wp_parse_args( [
								'property' 	=> 'margin',
								'value'	  	=> $margin,
								'units'		=> '!important'
							], $output );
						} else {
							foreach( $margin as $dir => $val ) {
								// Is WP way of saved color
								if( mb_strpos( $val, '|' ) !== false ) {
									$val = explode( '|', $val );
									$val = sprintf( 'var(--wp--preset--spacing--%s)', end( $val ) );
								}

								$this->output[] = wp_parse_args( [
									'property' 	=> 'margin-' . $dir,
									'value'	  	=> $val,
									'units'		=> '!important'
								], $output );
							}
						}
					}
				}
			}

			// Border
			if ( $border = get_prop( $css_style, 'border' ) ) {

				// Handle individual borders in upcoming WP 6.1
				$directions = wp_array_slice_assoc( $border, [ 'top', 'left', 'right', 'bottom' ] );

				foreach( $directions as $dir => $value ) {
					$color = get_prop( $value, 'color' );
					if ( strpos( $color, 'var:preset|color' ) !== false ) {
						$color = sprintf( 'var(--wp--preset--color--%s)', substr( $color, strrpos( $color, '|' ) + 1 ) );
					}

					$this->output[] = wp_parse_args( [
						'property' 	=> 'border-' . $dir,
						'value'	  	=> trim( sprintf(
							'%s %s %s',
							get_prop( $value, 'width' ),
							get_prop( $value, 'style', 'solid' ),
							$color
						) )
					], $output );
				}

				if ( $value = get_prop( $border, 'width' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'border-width',
						'value'	  	=> $value
					], $output );
				}

				if ( $value = get_prop( $border, 'style' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'border-style',
						'value'	  	=> $value
					], $output );
				}

				if ( $value = get_prop( $border, 'color' ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'border-color',
						'value'	  	=> $value
					], $output );
				}

				if ( $value = get_prop( $border, 'radius' ) ) {
					if ( is_array( $value ) ) {
						// We have individual border radius corner values.
						foreach ( $value as $key => $radius ) {
							// Convert CamelCase corner name to kebab-case.
							$corner   = strtolower( preg_replace( '/(?<!^)[A-Z]/', '-$0', $key ) );
							$this->output[] = wp_parse_args( [
								'property' 	=> sprintf( 'border-%s-radius', $corner ),
								'value'	  	=> $radius,
							], $output );
						}
					} else {
						$this->output[] = wp_parse_args( [
							'property' 	=> 'border-radius',
							'value'	  	=> $value,
							'units'		=> is_numeric( $value ) ? 'px' : null
						], $output );
					}
				}
			}

			// Elements
			if ( $link = get_prop( $css_style, [ 'elements', 'link', 'color', 'text' ] ) ) {
				if ( strpos( $link, 'var:preset|color' ) !== false ) {
					// Get the name from the string and add proper styles.
					$name 	= substr( $link, strrpos( $link, '|' ) + 1 );
					$this->output[] = wp_parse_args( [
						'element'	=> implode( ' ', [ $this->element, 'a' ] ),
						'property' 	=> 'color',
						'value'	  	=> sprintf( 'var(--wp--preset--color--%s)', $name )
					], $output );
				} else {
					$this->output[] = wp_parse_args( [
						'element'	=> implode( ' ', [ $this->element, 'a' ] ),
						'property' 	=> 'color',
						'value'	  	=> $link
					], $output );
				}
			}
		}
	}
	
	/**
	 * Parses custom CSS.
	 *
	 * @return 	void
	 */
	protected function parse_custom() {
		if ( $css_custom = get_prop( $this->attrs, 'customCSS', false ) ) {
			$custom_style 	= wp_strip_all_tags( $css_custom );
			$custom_style 	= str_replace( 'selector', $this->get_element(), $custom_style );
			$custom_style 	= wecodeart( 'styles' )::string_to_array_query( $custom_style );
			// Array replace existing CSS rules - custom overwrites everything
			$this->styles 	= array_replace_recursive( $this->styles, $custom_style );
		}
	}

	/**
	 * Get duotone.
	 *
	 * @return 	array
	 */
	public function get_duotone() {
		$return 	= false;
		$duotone 	= get_prop( $this->attrs, [ 'style', 'color', 'duotone' ], false );

		if( $duotone ) {
			$return = wecodeart( 'styles' )::get_duotone( [ 'colors' => $duotone ] );
		}

		return $return;
	}

	/**
	 * Get classnames.
	 *
	 * @return 	array
	 */
	public function get_classes() {
		return array_unique( array_filter( explode( ' ', get_prop( $this->attrs, 'className', '' ) ) ) );
	}
	
	/**
	 * Get uniqueID.
	 *
	 * @return 	array
	 */
	public function get_element() {
		return $this->element;
	}
}