<?php
/**
 * WeCodeArt Framework
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package		WeCodeArt Framework
 * @subpackage  Gutenberg CSS Frontend
 * @copyright   Copyright (c) 2021, WeCodeArt Framework
 * @since		5.0.0
 * @version		5.0.0
 */

namespace WeCodeArt\Gutenberg\Modules\Styles;

defined( 'ABSPATH' ) || exit();

use WeCodeArt\Support\Styles\Processor;
use function WeCodeArt\Functions\get_prop;

/**
 * Block CSS Processor
 *
 * This class handles all the Gutenberg Core styles from attributes found under style object or theme customs.
 * Any extends of this class, should use process_extra() method for extending the attributes processor.
 */
class Blocks extends Processor {

	/**
	 * Block Name.
	 *
	 * @var 	string
	 */
	protected 	$name 		= '';
	protected 	$element 	= '';

	/**
	 * Block Attrs.
	 *
	 * @var 	array
	 */
	protected 	$attrs = [];

	/**
	 * The class constructor.
	 *
	 * @access 	public
	 * @param 	array 	$args The block args.
	 */
	public function __construct( $args ) {
		$this->name		= get_prop( $args, 'blockName' );
		$this->attrs	= get_prop( $args, 'attrs', [] );

		// Set unique class
		$this->set_element();

		// Process CSS
		$this->process_attributes();
		if( method_exists( $this, 'process_extra' ) ) {
			// Extra attributes
			$this->process_extra();
		}

		// Parse CSS
		$this->parse_output();
		$this->parse_custom();
	}

	/**
	 * Setup element unique class.
	 *
	 * @return 	mixed
	 */
	private function set_element() {
		$block_class 	= substr( get_prop( $this->attrs, 'customCSSId' ), 0, 8 );
		$this->element = '.css-' . sanitize_html_class( $block_class );
	}

	/**
	 * Parses an output and creates the styles array for it.
	 *
	 * @return 	void
	 */
	protected function process_attributes() {
		$this->output = [];

		$output 			= [];
		$output['element'] 	= $this->element;

		// Layout
		// if( $layout = get_prop( $this->attrs, 'layout', false ) ) {
		// 	if ( isset( $layout['inherit'] ) && $layout['inherit'] ) {
		// 		$default_layout = wecodeart_json( [ 'settings', 'layout' ], false );
		// 		if ( $default_layout ) {
		// 			$layout = $default_layout;
		// 		}
		// 	}

		// 	$size_default 	= get_prop( $layout, 'contentSize', null );
		// 	$size_wide    	= get_prop( $layout, 'wideSize', null );
		// 	$size_default 	= $size_default ?: $size_wide;
		// 	$size_wide 		= $size_wide ?: $size_default;

		// 	if( $size_default || $size_wide ) {
		// 		$this->styles["@media (min-width: {$size_default})"][$this->element . '>div[class*="container"]']['max-width'] = $size_default;
		// 		$this->styles["@media (min-width: {$size_default})"][$this->element . ' .alignwide']['max-width'] = $size_wide;
		// 	}
		// }
		
		// Inline Style
		if( $css_style = get_prop( $this->attrs, 'style', false ) ) {
			// Typography
			if ( $typography = get_prop( $css_style, 'typography', false ) ) {
				if ( $value = get_prop( $typography, 'fontFamily', false ) ) {
					if ( strpos( $value, 'var:preset|font-family' ) !== false ) {
						// Get the name from the string and add proper styles.
						$name 	= substr( $value, strrpos( $value, '|' ) + 1 );
						$this->output[] = wp_parse_args( [
							'property' 	=> 'font-family',
							'value'	  	=> sprintf( 'var(--wp--preset--font-family--%s)', $name )
						], $output );
					}
				}

				if ( $value = get_prop( $typography, 'fontSize', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'font-size',
						'value'	  	=> $value,
						'units'	  	=> 'px'
					], $output );
				}
	
				if ( $value = get_prop( $typography, 'fontStyle', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'font-weight',
						'value'	  	=> $value
					], $output );
				}
				
				if ( $value = get_prop( $typography, 'lineHeight', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'line-height',
						'value'	  	=> $value,
					], $output );
				}
	
				if ( $value = get_prop( $typography, 'textTransform', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'text-transform',
						'value'	  	=> $value
					], $output );
				}
	
				if ( $value = get_prop( $typography, 'textDecoration', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'text-decoration',
						'value'	  	=> $value
					], $output );
				}
			}

			// Colors
			if ( $color = get_prop( $css_style, 'color', false ) ) {
				// Text
				if ( $value = get_prop( $color, 'text', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'color',
						'value'	  	=> $value
					], $output );
				}

				// Background
				if ( $value = get_prop( $color, 'background', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'background-color',
						'value'	  	=> $value
					], $output );
				}

				// Gradient
				if ( $value = get_prop( $color, 'gradient', false ) ) {
					$this->output[] = wp_parse_args( [
						'element'	=> implode( '>', [ $this->element, '.wp-block__gradient-background' ] ),
						'property' 	=> 'background-image',
						'value'	  	=> $value
					], $output );
				}
				
				// Duotone
				if ( $value = get_prop( $color, 'duotone', false ) ) {
					$block_type = \WP_Block_Type_Registry::get_instance()->get_registered( $this->name );

					$duotone_support = false;
					if ( $block_type && property_exists( $block_type, 'supports' ) ) {
						$duotone_support = get_prop( $block_type->supports, [ 'color', '__experimentalDuotone' ], false );
					}

					if( $duotone_support ) {
						$selector_array = explode( '-', $this->element );
						$this->output[] = wp_parse_args( [
							'element'	=> implode( ', ', array_map( function ( $selector ) {
								return implode( ' ', [ $this->element, trim( $selector ) ] );
							}, explode( ',', $duotone_support ) ) ),
							'property' 	=> 'filter',
							'value'	  	=> sprintf( 'url( #%s )', end( $selector_array ) )
						], $output );
					}
				}
			}

			// Spacing
			if( $spacing = get_prop( $css_style, 'spacing', false ) ) {
				if ( $padding = get_prop( $spacing, 'padding', [] ) ) {
					if( ! empty( $padding ) ) {
						foreach( $padding as $dir => $val ) {
							$this->output[] = wp_parse_args( [
								'property' 	=> 'padding-' . $dir,
								'value'	  	=> $val
							], $output );
						}
					}
				}

				if ( $margin = get_prop( $spacing, 'margin', [] ) ) {
					if( ! empty( $margin ) ) {
						foreach( $margin as $dir => $val ) {
							$this->output[] = wp_parse_args( [
								'property' 	=> 'margin-' . $dir,
								'value'	  	=> $val
							], $output );
						}
					}
				}
			}

			// Border
			if( $border = get_prop( $css_style, 'border', [] ) ) {
				if ( $value = get_prop( $border, 'width', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'border-width',
						'value'	  	=> $value
					], $output );
				}
				if ( $value = get_prop( $border, 'style', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'border-style',
						'value'	  	=> $value
					], $output );
				}
				if ( $value = get_prop( $border, 'radius', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'border-radius',
						'value'	  	=> $value
					], $output );
				}
				if ( $value = get_prop( $border, 'color', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'border-color',
						'value'	  	=> $value
					], $output );
				}
			}

			// Elements
			if( $elements = get_prop( $css_style, 'elements', false ) ) {
				if ( $link = get_prop( $elements, 'link', false ) ) {
					if ( $color = get_prop( $link, 'color', false ) ) {
						if ( $value = get_prop( $color, 'text', false ) ) {
							if ( strpos( $value, 'var:preset|color' ) !== false ) {
								// Get the name from the string and add proper styles.
								$name 	= substr( $value, strrpos( $value, '|' ) + 1 );
								$this->output[] = wp_parse_args( [
									'element'	=> implode( ' ', [ $this->element, 'a' ] ),
									'property' 	=> 'color',
									'value'	  	=> sprintf( 'var(--wp--preset--color--%s)', $name )
								], $output );
							}
						}
					}
				}
			}
		}
	}
	
	/**
	 * Parses and attach Custom CSS
	 *
	 * @return 	void
	 */
	private function parse_custom() {
		if ( $css_custom = get_prop( $this->attrs, 'customCSS', false ) ) {
			$custom_style 	= wp_strip_all_tags( $css_custom );
			$custom_style 	= str_replace( 'selector', $this->element, $custom_style );
			$custom_style 	= wecodeart( 'integrations' )->get( 'styles' )::break_queries( $custom_style );
			$this->styles 	= array_replace_recursive( $this->styles, $custom_style );
		}
	}
}