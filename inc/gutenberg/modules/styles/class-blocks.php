<?php
/**
 * WeCodeArt Framework
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package		WeCodeArt Framework
 * @subpackage  Gutenberg CSS Frontend
 * @copyright   Copyright (c) 2021, WeCodeArt Framework
 * @since		5.0.0
 * @version		5.2.2
 */

namespace WeCodeArt\Gutenberg\Modules\Styles;

defined( 'ABSPATH' ) || exit();

use WeCodeArt\Support\Styles\Processor;
use function WeCodeArt\Functions\get_prop;

/**
 * Block CSS Processor
 *
 * This class handles all the Gutenberg Core styles from attributes found under style object or theme customs.
 * Any extends of this class, should use process_extra() method for extending the attributes processor.
 */
class Blocks extends Processor {

	/**
	 * Block Name.
	 *
	 * @var 	string
	 */
	protected 	$name 		= '';
	protected 	$element 	= '';

	/**
	 * Block Attrs.
	 *
	 * @var 	array
	 */
	protected 	$attrs = [];

	/**
	 * The class constructor.
	 *
	 * @access 	public
	 * @param 	array 	$args The block args.
	 */
	public function __construct( $args ) {
		$this->name		= get_prop( $args, 'blockName' );
		$this->attrs	= get_prop( $args, 'attrs', [] );

		// Set unique class
		$this->set_element();

		// Process CSS
		$this->process_attributes();
		if( method_exists( $this, 'process_extra' ) ) {
			// Extra attributes
			$this->process_extra();
		}

		// Parse CSS
		$this->parse_output();
		$this->parse_custom();
	}

	/**
	 * Setup element unique class.
	 *
	 * @return 	mixed
	 */
	protected function set_element() {
		$block_class 	= substr( get_prop( $this->attrs, 'customCSSId' ), 0, 8 );
		$this->element = '.css-' . sanitize_html_class( $block_class );
	}

	/**
	 * Parses attributes and creates the styles array for them.
	 *
	 * @return 	void
	 */
	protected function process_attributes() {
		$this->output = [];

		$output 			= [];
		$output['element'] 	= $this->element;

		// Layout - we do not support wide align yet but it will be enabled in a future version!
		if( $layout = get_prop( $this->attrs, 'layout', false ) ) {
			$type = get_prop( $layout, 'type', 'default' );
			// if ( get_prop( $layout, 'inherit', null ) ) {
			// 	$default_layout = wecodeart_json( [ 'settings', 'layout' ], false );
			// 	if ( $default_layout ) {
			// 		$layout = $default_layout;
			// 	}
			// }

			// $size_default 	= get_prop( $layout, 'contentSize', null );
			// $size_wide    	= get_prop( $layout, 'wideSize', null );
			// $size_default 	= $size_default ?: $size_wide;
			// $size_wide 		= $size_wide ?: $size_default;

			// if( $size_default || $size_wide ) {
			// 	$this->styles["@media (min-width: {$size_default})"][$this->element . '>div[class*="container"]']['max-width'] = $size_default;
			// 	$this->styles["@media (min-width: {$size_default})"][$this->element . ' .alignwide']['max-width'] = $size_wide;
			// }

			if( $type === 'flex' ) {
				$orientation	= get_prop( $layout, 'orientation', 'horizontal' );
				$justification 	= get_prop( $layout, 'justifyContent' );

				$justify_options 	= [
					'left'   => 'flex-start',
					'right'  => 'flex-end',
					'center' => 'center',
				];

				if ( 'horizontal' === $orientation ) {
					$justify_options += [ 'space-between' => 'space-between' ];
				}
				
				$wrap_options 	= [ 'wrap', 'nowrap' ];
				$flex_wrap 		= get_prop( $layout, 'flexWrap', 'wrap' );
				$flex_wrap 		= in_array( $flex_wrap, $wrap_options ) ? $flex_wrap : 'wrap';

				$this->output[] = wp_parse_args( [
					'property' 	=> 'display',
					'value'	  	=> 'flex'
				], $output );

				$this->output[] = wp_parse_args( [
					'property' 	=> 'flex-wrap',
					'value'	  	=> $flex_wrap
				], $output );
				
				if ( 'horizontal' === $orientation ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'align-items',
						'value'	  	=> 'center'
					], $output );

					$backwards = 'justify-content';
				} else {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'flex-direction',
						'value'	  	=> 'column'
					], $output );

					$backwards = 'align-items';
				}

				// Backwards
				if ( ! empty( $justification ) && array_key_exists( $justification, $justify_options ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> $backwards,
						'value'	  	=> $justify_options[ $justification ]
					], $output );
				}

				$this->output[] = wp_parse_args( [
					'element'	=> join( '>', [ $this->element, '*' ] ),
					'property' 	=> 'margin',
					'value'	  	=> '0'
				], $output );
			}
		}
		
		// Inline Style
		if( $css_style = get_prop( $this->attrs, 'style', false ) ) {
			// Typography
			if ( $typography = get_prop( $css_style, 'typography', false ) ) {
				if ( $value = get_prop( $typography, 'fontFamily', false ) ) {
					if ( strpos( $value, 'var:preset|font-family' ) !== false ) {
						// Get the name from the string and add proper styles.
						$name 	= substr( $value, strrpos( $value, '|' ) + 1 );
						$this->output[] = wp_parse_args( [
							'property' 	=> 'font-family',
							'value'	  	=> sprintf( 'var(--wp--preset--font-family--%s)', $name )
						], $output );
					}
				}

				if ( $value = get_prop( $typography, 'fontSize', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'font-size',
						'value'	  	=> $value,
					], $output );
				}
	
				if ( $value = get_prop( $typography, 'fontWeight', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'font-weight',
						'value'	  	=> $value
					], $output );
				}

				if ( $value = get_prop( $typography, 'fontStyle', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'font-style',
						'value'	  	=> $value
					], $output );
				}
				
				if ( $value = get_prop( $typography, 'lineHeight', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'line-height',
						'value'	  	=> $value,
					], $output );
				}
	
				if ( $value = get_prop( $typography, 'textTransform', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'text-transform',
						'value'	  	=> $value
					], $output );
				}
	
				if ( $value = get_prop( $typography, 'textDecoration', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'text-decoration',
						'value'	  	=> $value
					], $output );
				}
				
				if ( $value = get_prop( $typography, 'letterSpacing', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'letter-spacing',
						'value'	  	=> $value
					], $output );
				}
			}

			// Colors
			if ( $color = get_prop( $css_style, 'color', false ) ) {
				// Text
				if ( $value = get_prop( $color, 'text', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'color',
						'value'	  	=> $value
					], $output );
				}

				// Background
				if ( $value = get_prop( $color, 'background', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'background-color',
						'value'	  	=> $value
					], $output );
				}

				// Gradient
				if ( $value = get_prop( $color, 'gradient', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'background-image',
						'value'	  	=> $value
					], $output );
				}
				
				// Duotone - temporary disable until I combine them into our styles
				if ( $value = get_prop( $color, 'duotone', false ) ) {
					$block_type = \WP_Block_Type_Registry::get_instance()->get_registered( $this->name );

					$duotone_support = false;
					if ( $block_type && property_exists( $block_type, 'supports' ) ) {
						$duotone_support = get_prop( $block_type->supports, [ 'color', '__experimentalDuotone' ], false );
					}

					if( $duotone_support ) {
						$selector_array = explode( '-', $this->element );
						$this->output[] = wp_parse_args( [
							'element'	=> implode( ', ', array_map( function ( $selector ) {
								return implode( ' ', [ $this->element, trim( $selector ) ] );
							}, explode( ',', $duotone_support ) ) ),
							'property' 	=> 'filter',
							'value'	  	=> sprintf( 'url(#wp-duotone-%s)', end( $selector_array ) )
						], $output );
					}
				}
			}

			// Spacing
			if( $spacing = get_prop( $css_style, 'spacing', false ) ) {
				if ( $padding = get_prop( $spacing, 'padding', [] ) ) {
					if( ! empty( $padding ) ) {
						foreach( $padding as $dir => $val ) {
							$this->output[] = wp_parse_args( [
								'property' 	=> 'padding-' . $dir,
								'value'	  	=> $val
							], $output );
						}
					}
				}

				if ( $margin = get_prop( $spacing, 'margin', [] ) ) {
					if( ! empty( $margin ) ) {
						foreach( $margin as $dir => $val ) {
							$this->output[] = wp_parse_args( [
								'property' 	=> 'margin-' . $dir,
								'value'	  	=> $val
							], $output );
						}
					}
				}
			}

			// Border
			if( $border = get_prop( $css_style, 'border', [] ) ) {
				if ( $value = get_prop( $border, 'width', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'border-width',
						'value'	  	=> $value
					], $output );
				}
				if ( $value = get_prop( $border, 'style', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'border-style',
						'value'	  	=> $value
					], $output );
				}
				if ( $value = get_prop( $border, 'radius', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'border-radius',
						'value'	  	=> $value
					], $output );
				}
				if ( $value = get_prop( $border, 'color', false ) ) {
					$this->output[] = wp_parse_args( [
						'property' 	=> 'border-color',
						'value'	  	=> $value
					], $output );
				}
			}

			// Elements
			if( $elements = get_prop( $css_style, 'elements', false ) ) {
				if ( $link = get_prop( $elements, 'link', false ) ) {
					if ( $color = get_prop( $link, 'color', false ) ) {
						if ( $value = get_prop( $color, 'text', false ) ) {
							if ( strpos( $value, 'var:preset|color' ) !== false ) {
								// Get the name from the string and add proper styles.
								$name 	= substr( $value, strrpos( $value, '|' ) + 1 );
								$this->output[] = wp_parse_args( [
									'element'	=> implode( ' ', [ $this->element, 'a' ] ),
									'property' 	=> 'color',
									'value'	  	=> sprintf( 'var(--wp--preset--color--%s)', $name )
								], $output );
							} else {
								$this->output[] = wp_parse_args( [
									'element'	=> implode( ' ', [ $this->element, 'a' ] ),
									'property' 	=> 'color',
									'value'	  	=> $value
								], $output );
							}
						}
					}
				}
			}
		}
	}
	
	/**
	 * Parses custom CSS.
	 *
	 * @return 	void
	 */
	protected function parse_custom() {
		if ( $css_custom = get_prop( $this->attrs, 'customCSS', false ) ) {
			$custom_style 	= wp_strip_all_tags( $css_custom );
			$custom_style 	= str_replace( 'selector', $this->element, $custom_style );
			$custom_style 	= wecodeart( 'integrations' )->get( 'styles' )::break_queries( $custom_style );
			$this->styles 	= array_replace_recursive( $this->styles, $custom_style );
		}
	}

	/**
	 * Get duotone.
	 *
	 * @return 	void
	 */
	public function get_duotone() {
		$return 	= false;
		$duotone 	= get_prop( $this->attrs, [ 'style', 'color', 'duotone' ], false );

		if( $duotone ) {
			$return = [
				'r' => [],
				'g' => [],
				'b' => [],
				'a' => [],
			];

			foreach ( $duotone as $color ) {
				$function = 'wp_tinycolor_string_to_rgb';
				if( function_exists( 'gutenberg_tinycolor_string_to_rgb' ) ) {
					$function = 'gutenberg_tinycolor_string_to_rgb';
				}

				$color = $function( $color );
				$return['r'][] = $color['r'] / 255;
				$return['g'][] = $color['g'] / 255;
				$return['b'][] = $color['b'] / 255;
				$return['a'][] = $color['a'];
			}
		}

		return $return;
	}
}