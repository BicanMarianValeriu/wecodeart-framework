<?php
/**
 * WeCodeArt Framework
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package		WeCodeArt Framework
 * @subpackage  Gutenberg CSS Module
 * @copyright   Copyright (c) 2021, WeCodeArt Framework
 * @since		4.0.3
 * @version		5.0.0
 */

namespace WeCodeArt\Gutenberg\Modules;

defined( 'ABSPATH' ) || exit();

use WeCodeArt\Singleton;
use WeCodeArt\Gutenberg;
use WeCodeArt\Integration;
use WeCodeArt\Core\Scripts;
use function WeCodeArt\Functions\get_prop;

/**
 * Handles Gutenberg Theme CSS Functionality.
 */
class Styles implements Integration {

	use Singleton;
	use Scripts\Base;

	/**
	 * The Styles Processor
	 *
	 * @access 	public
	 * @var 	null|object
	 */
	public $styles = null;

	/**
	 * Get Conditionals
	 *
	 * @return void
	 */
	public static function get_conditionals() {
		wecodeart( 'conditionals' )->set( [
			'with_blocks_styles' => Styles\Condition::class,
		] );

		return [ 'with_blocks_styles' ];
	}

	/**
	 * Register Hooks - into styles processor action if enabled
	 *
	 * @since 	5.0.0
	 *
	 * @return 	void
	 */
	public function register_hooks() {
		$this->styles = wecodeart( 'integrations' )->get( 'styles' );
		
		// CSS Handler
		Styles\Handler::get_instance();
		// Enqueue Styles
		Styles\Embed::get_instance();
		// Admin
		add_action( 'enqueue_block_editor_assets',	[ $this, 'block_editor_assets' ], 0 );
		add_filter( 'render_block',					[ $this, 'filter_render' ], 10, 2 );
		add_filter( 'block_default_classname',		[ $this, 'filter_classname' ], 20, 2 );
	}

	/**
	 * Editor only.
	 *
	 * @return  void
	 */
	public function block_editor_assets() {
		wp_enqueue_script( $this->make_handle(), $this->get_asset( 'js', 'gutenberg-styles' ), [
			'wecodeart-gutenberg-inline'
		], wecodeart( 'version' ) );
	}

	/**
	 * Filter Blocks Classname
	 *
	 * @param	string 	$classname
	 * @param	string 	$block
	 *
	 * @return 	string 	HTML
	 */
	public function filter_classname( $classname, $block ) {
		// $classname = 'test';
		return $classname;
	}

	/**
	 * Filter Blocks markup to remove styles
	 *
	 * @param	string 	$block_content
	 * @param	array 	$block
	 *
	 * @return 	string 	HTML
	 */
	public function filter_render( $content, $block ) {
		// We use this approach to avoid invalid blocks or patterns, as well as on theme change
		$doc = new \DOMDocument();
		// See https://github.com/WordPress/gutenberg/blob/trunk/packages/block-library/src/table-of-contents/index.php
		// And this is using markup from Gutenberg blocks so is kinda safe anyway
		libxml_use_internal_errors( true );
		$doc->loadHTML( htmlspecialchars_decode(
			utf8_decode( htmlentities( '<html><body>' . $content . '</body></html>', ENT_COMPAT, 'UTF-8', false ) ),
			ENT_COMPAT
		) );
		libxml_use_internal_errors( false );

		// Append CSS class
		$xpath 	= new \DomXPath( $doc );
		$domEls	= $xpath->query('//div[starts-with(@class,"wp-block-")]');
		if( $domEls->length >= 1 ) {
			$domEl  = $domEls->item(0);
			$cssid  = 'css-' . substr( get_prop( $block['attrs'], 'customCSSId' ), 0, 8 );
			$class 	= join( ' ', [ $domEl->getAttribute( 'class' ), $cssid ] );
			$domEl->setAttribute( 'class', $class );
		}

		// Remove styles, where needed
		if ( in_array( $block['blockName'], (array) apply_filters( 'wecodeart/filter/gutenberg/styles/remove', [
			'core/group',
			'core/cover',
			'core/media-text',
			'core/pullquote',
		], true ) ) ) {
			$elements = $doc->getElementsByTagName( '*' );
			foreach( $elements as $el ) $el->removeAttribute( 'style' );
		}

		// Save new HTML
		$content = $doc->saveHTML();
		
		return $content;
	}

	/**
	 * Get Blocks CSS
	 *
	 * @since   5.0.0
	 * @param 	int 	$post_id Post id.
	 *
	 * @return 	string
	 */
	public function get_blocks_css( $post_id ) {
		$content = get_post_field( 'post_content', $post_id );
		$blocks  = Gutenberg::parse_blocks( $content );

		if ( ! is_array( $blocks ) || empty( $blocks ) ) {
			return;
		}

		return $this->cycle_through_static_blocks( $blocks );
	}

	/**
	 * Get Reusable Blocks CSS
	 *
	 * @since   5.0.0
	 * @param 	int 	$post_id Post id.
	 *
	 * @return 	string
	 */
	public function get_reusable_block_css( $block_id ) {
		$reusable_block = get_post( $block_id );

		if ( ! $reusable_block || 'wp_block' !== $reusable_block->post_type ) {
			return;
		}

		if ( 'publish' !== $reusable_block->post_status || ! empty( $reusable_block->post_password ) ) {
			return;
		}

		$blocks = Gutenberg::parse_blocks( $reusable_block->post_content );

		return $this->cycle_through_static_blocks( $blocks );
	}

	/**
	 * Cycle thorugh Static Blocks
	 *
	 * @since   5.0.0
	 * @param 	array 	$blocks List of blocks.
	 *
	 * @return 	string 	Style.
	 */
	public function cycle_through_static_blocks( $blocks ) {
		$style = '';
		foreach ( $blocks as $block ) {
			$style .= $this->styles::parse( $this->styles::add_prefixes( self::process_block( $block ) ) );

			if ( isset( $block['innerBlocks'] ) && ! empty( $block['innerBlocks'] ) && is_array( $block['innerBlocks'] ) ) {
				$style .= $this->cycle_through_static_blocks( $block['innerBlocks'] );
			}
		}

		return $style;
	}

	/**
	 * Cycle thorugh Reusable Blocks
	 *
	 * @since   5.0.0
	 * @param 	array 	$blocks List of blocks.
	 *
	 * @return 	string 	Style.
	 */
	public function cycle_through_reusable_blocks( $blocks ) {
		$style = '';
		foreach ( $blocks as $block ) {
			if ( 'core/block' === $block['blockName'] && ! empty( $block['attrs']['ref'] ) ) {
				$style .= $this->get_reusable_block_css( $block['attrs']['ref'] );
			}

			if ( isset( $block['innerBlocks'] ) && ! empty( $block['innerBlocks'] ) && is_array( $block['innerBlocks'] ) ) {
				$style .= $this->cycle_through_reusable_blocks( $block['innerBlocks'] );
			}
		}

		return $style;
	}

	/**
	 * Get the CSS for a block.
	 *
	 * @param 	array 	$args The block.
	 *
	 * @return 	array
	 */
	public static function process_block( $block = [] ) {
		// Find the class that will handle the output for this block.
		$classname	= Styles\Blocks::class;
		$defaults   = [
			'core/cover' 		=> Styles\Blocks\Cover::class,
			'core/media-text' 	=> Styles\Blocks\Media::class,
			'core/button' 		=> Styles\Blocks\Button::class,
			'core/separator' 	=> Styles\Blocks\Separator::class,
			'core/pullquote' 	=> Styles\Blocks\PullQuote::class
		];

		$output_classes = apply_filters( 'wecodeart/filter/gutenberg/styles/blocks', $defaults );

		if ( array_key_exists( $block['blockName'], $output_classes ) ) {
			$classname = $output_classes[ $block['blockName'] ];
		}
		
		if( class_exists( $classname ) ) {
			$obj = new $classname( $block );
	
			return $obj->get_styles();
		};
	}
}
