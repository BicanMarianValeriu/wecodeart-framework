<?php
/**
 * WeCodeArt Framework
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package		WeCodeArt Framework
 * @subpackage  Gutenberg Patterns
 * @copyright   Copyright (c) 2021, WeCodeArt Framework
 * @since		5.0.0
 * @version		5.0.0
 */

namespace WeCodeArt\Gutenberg\Modules;

defined( 'ABSPATH' ) || exit();

use WeCodeArt\Singleton;
use WeCodeArt\Integration;
use WeCodeArt\Core\Scripts;
use function WeCodeArt\Functions\get_prop;
use function WeCodeArt\Functions\wp_parse_args_r;

/**
 * Handles Gutenberg Theme Patterns Functionality.
 */
class Patterns implements Integration {

	use Singleton;
	use Scripts\Base;

	/**
	 * Folder.
	 *
	 * @var string
	 */
	const FOLDER	= 'block-patterns';

	/**
	 * Config.
	 *
	 * @var array
	 */
	public $config = [];

	/**
	 * Get Conditionals
	 *
	 * @return void
	 */
	public static function get_conditionals() {
		wecodeart( 'conditionals' )->set( [
			'with_gutenberg_patterns' => Patterns\Condition::class,
		] );

		return [ 'with_gutenberg_patterns' ];
	}

	/**
	 * Register Hooks
	 *
	 * @since 	5.0.0
	 *
	 * @return 	void
	 */
	public function register_hooks() {
		// Editor Assets.
		// add_action( 'enqueue_block_editor_assets', [ $this, 'block_editor_assets' ], 10 );
		// Register.
		$this->set_config();
		$this->register_categories();
		$this->register_patterns();
	}

	/**
	 * Editor only.
	 *
	 * @return  void
	 */
	public function block_editor_assets() {
		wp_enqueue_script( $this->make_handle(), $this->get_asset( 'js', 'gutenberg-patterns' ), [
			'wecodeart-gutenberg'
		], wecodeart( 'version' ) );
	}

	/**
	 * Set config.
	 *
	 * @return  void
	 */
	public function set_config() {
		$this->config = get_prop( wecodeart_config( 'gutenberg' ), 'patterns', [] );
	}

	/**
	 * Register block patterns categories.
	 *
	 * @return 	void
	 */
	public function register_categories() {
		( new Patterns\Categories( get_prop( $this->config, 'categories', [] ) ) )->register();
	}

	/**
	 * Register block patterns.
	 *
	 * @return 	void
	 */
	public function register_patterns() {
		$query = $this->get_files();

		if( empty( $query ) ) return;

		foreach( $query as $pattern ) $this->get_pattern_from_file( $pattern['slug'] );
	}

	/**
	 * Link Reusable blocks to Appearance
	 *
	 * @return void
	 */
	public function get_paths( $base_directory ) {
		$path_list = array();
		if ( file_exists( $base_directory ) ) {
			$nested_files      = new \RecursiveIteratorIterator( new \RecursiveDirectoryIterator( $base_directory ) );
			$nested_html_files = new \RegexIterator( $nested_files, '/^.+\.html$/i', \RecursiveRegexIterator::GET_MATCH );
			foreach ( $nested_html_files as $path => $file ) {
				$path_list[] = $path;
			}
		}
		return $path_list;
	}

	/**
	 * Retrieves the template files from  the theme.
	 *
	 * @return 	array 	Template.
	 */
	public function get_files() {
		$themes = [
			get_stylesheet() => get_prop( wecodeart_config( 'paths' ), 'child' ),
			get_template()   => get_prop( wecodeart_config( 'paths' ), 'directory' ),
		];

		$template_files = [];
		foreach ( $themes as $theme_slug => $theme_dir ) {
			$theme_files = $this->get_paths( $theme_dir . '/' . self::FOLDER );
			foreach ( $theme_files as $file ) {
				$template_slug      = substr(
					$file,
					// Starting position of slug.
					strpos( $file, self::FOLDER . DIRECTORY_SEPARATOR ) + 1 + strlen( self::FOLDER ),
					// Subtract ending '.html'.
					-5
				);

				$template_files[] = [
					'slug'  => $template_slug,
					'path'  => $file,
					'theme' => $theme_slug,
				];
			}
		}
		
		return $template_files;
	}

	/**
	 * Retrieves the template file from the theme for a given slug.
	 *
	 * @access 	private
	 *
	 * @param 	string 	$slug template slug.
	 *
	 * @return 	array 	Template.
	 */
	public function get_file( $slug ) {
		$themes = [
			get_stylesheet() => get_prop( wecodeart_config( 'paths' ), 'child' ),
			get_template()   => get_prop( wecodeart_config( 'paths' ), 'directory' ),
		];

		foreach ( $themes as $theme_slug => $theme_dir ) {
			$file_path = wp_normalize_path( $theme_dir . '/' . self::FOLDER . '/' . $slug . '.html' );
			if ( file_exists( $file_path ) ) {
				$new_template_item = [
					'slug'  => $slug,
					'path'  => $file_path,
					'theme' => $theme_slug
				];

				return $new_template_item;
			}
		}

		return null;
	}

	/**
	 * Build a unified template object based on a theme file.
	 *
	 * @param 	array 	$template_file Theme file.
	 *
	 * @return 	WP_Block_Template Template.
	 */
	public function register_from_file( $template_file ) {
		$template_content	= file_get_contents( $template_file['path'] );

		$template			= new Patterns\Pattern();
		$template->name		= $template_file['slug'];
		$template->title	= ucfirst( implode( ' ', explode( '-', $template_file['slug'] ) ) );
		$template->content	= $template_content;
		$template->slug		= $template_file['slug'];
		$template->theme	= 'wecodeart';

		return $template->register();
	}

	/**
	 * Retrieves a single unified template object using its id.
	 * Retrieves the file template.
	 *
	 * @param 	string 	$slug Template unique identifier (example: template_slug).
	 *
	 * @return 	WP_Block_Template|null File template.
	 */
	public function get_pattern_from_file( $slug ) {
		$template_file = $this->get_file( $slug );

		if ( null !== $template_file ) {
			return $this->register_from_file( $template_file );
		}

		return null;
	}
}
