<?php
/**
 * WeCodeArt Framework
 *
 * WARNING: This file is part of the core WeCodeArt Framework. DO NOT edit this file under any circumstances.
 * Please do all modifications in the form of a child theme.
 *
 * @package		WeCodeArt Framework
 * @subpackage  Gutenberg CSS Frontend
 * @copyright   Copyright (c) 2025, WeCodeArt Framework
 * @since		6.1.2
 * @version		6.4.5
 */

namespace WeCodeArt\Gutenberg\Styles\Blocks;

defined( 'ABSPATH' ) || exit;

use WeCodeArt\Singleton;
use WeCodeArt\Gutenberg\Styles\Processor;
use function WeCodeArt\Functions\get_prop;

/**
 * Block CSS Processor
 */
class Group extends Processor {
	/**
	 * Parses an output and creates the styles array for it.
	 *
	 * @return 	void
	 */
	protected function process_style(): void {
		$declarations = [];

		// Marquee
		if( wecodeart( 'blocks' )->get( 'core/group' )::is_variation( $this->attrs, 'marquee' ) ) {
			$orientation 	= get_prop( $this->attrs, [ 'layout', 'orientation' ], 'horizontal' );
			$directionY 	= get_prop( $this->attrs, [ 'layout', 'verticalAlignment' ], 'center' );
			$directionX 	= get_prop( $this->attrs, [ 'layout', 'justifyContent' ], 'left' );

			// Handle direction 
			if( ( $orientation === 'vertical' && $directionY === 'bottom' ) || ( $orientation === 'horizontal' && $directionX === 'right' ) ) {
				$declarations['--marquee-direction'] = 'reverse';
			}

			// Handle alternate
			if( ( $orientation === 'vertical' && $directionY === 'space-between' ) || ( $orientation === 'horizontal' && $directionX === 'space-between' ) ) {
				$declarations['--marquee-direction'] = 'alternate';
			}

			// Handle pause state
			if( ( $orientation === 'vertical' && $directionY === 'center' ) || ( $orientation === 'horizontal' && $directionX === 'center' ) ) {
				$declarations['--marquee-state'] = 'paused';
			}

			// Handle gap
			if( $blockGap = get_prop( $this->attrs, [ 'style', 'spacing', 'blockGap' ] ) ) {
				$declarations['--marquee-gap'] = wecodeart( 'styles' )::format_variable( $blockGap );
			}

			$declarations['justify-content'] = 'initial';
			$declarations['flex-wrap'] = 'nowrap'; 

			$this->add_declarations( $declarations );
		}

		// Offcanvas
		if( wecodeart( 'blocks' )->get( 'core/group' )::is_variation( $this->attrs, 'offcanvas' ) ) {
			$directionY 	= get_prop( $this->attrs, [ 'layout', 'verticalAlignment' ] );
			$directionX 	= get_prop( $this->attrs, [ 'layout', 'justifyContent' ] );
			$orientation	= get_prop( $this->attrs, [ 'layout', 'orientation' ] );

			if( $directionY ) {
				$direction = $directionY === 'top' ? 'flex-start' : ( $directionY === 'bottom' ? 'flex-end' : $directionY );
				$declarations[$orientation === 'vertical' ? 'justify-content' : 'align-items'] = $direction;
			}

			if( $directionX ) {
				$declarations[$orientation === 'vertical' ? 'align-items' : 'justify-content'] = $directionX;
			}

			if( $orientation === 'vertical' ) {
				$declarations['flex-direction'] = 'column';
			}

			if( $blockGap = get_prop( $this->attrs, [ 'style', 'spacing', 'blockGap' ] ) ) {
				$declarations['gap'] = wecodeart( 'styles' )::format_variable( $blockGap );

				if( is_null( $orientation ) ) {
					$this->add_declarations( [
						'margin-block-start' => $declarations['gap']
					], $this->get_selector( ' .wp-offcanvas__body > *:not(:first-child)' ) );
					
					unset( $declarations['gap'] );
				}
			}

			if( ! empty( $declarations ) ) {
				$this->add_declarations( $declarations, $this->get_selector( ' .wp-offcanvas__body' ) );
			}
		}

		parent::process_style();
	}
}